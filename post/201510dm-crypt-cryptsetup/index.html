<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../post/index.xml">
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@SpeechFreedomCN">
    <meta name="twitter:creator" content="@SpeechFreedomCN">
    <meta name="og:title" content=" 扫盲 dm-crypt&amp;#8212;&amp;#8212;多功能 Linux 磁盘加密工具&amp;#65288;兼容 TrueCrypt 和 VeraCrypt&amp;#65289; | 编程随想镜像站 " />
    <meta name="og:description" content="很抱歉，又拖了好几天才更新博文。最近实在太忙了 :( 而且这篇博文的内容比较杂，整理起来也有点费时。 （本文发出后，俺顺便清理了博客管理界面的“留言垃圾箱”，里面有30多条“被 Google 误判为垃圾广告的留言”，刚才都已经恢复了）
9月底，TrueCrypt 曝光了高危安全漏洞。于是俺在10月初写了一篇教程，介绍 VeraCrypt 这个替代品——它可以完全覆盖 TrueCrypt 原有的功能，并且在安全方面还所有增强（比如用 PIM 来对抗“抗暴力破解”）。 那篇博文发出后，有些读者担心这个 VeraCrypt 本身是否可靠，是否会有后门。从目前 VeraCrypt 的口碑来看，这款工具应该还是比较靠谱滴！当然，俺无法向你担保 VeraCrypt 一定没有后门（谁都没法打这个包票）。 为了照顾那些“对安全性要求【特别高】的同学”，今天来介绍另一款磁盘加密工具——Linux 内核自带的“dm-crypt”。 另外，在本文的结尾部分，俺还会聊到：如何在【不使用】TrueCrypt/VeraCrypt 软件的情况下，挂载它们的加密盘。 既然是“扫盲”，本文主要面向那些不太懂技术的读者（技术菜鸟）。如今 Linux 已经比较普及了，有些技术菜鸟也开始玩 Linux。 如果你属于此类用户，并且你还比较关注隐私保护，希望用上磁盘加密工具。那么 Linux 内核自带的 dm-crypt 是一个不错的选择。 本文的主题，就是向技术菜鸟介绍 dm-crypt 的基本用法。 在某些技术文章中，“dm-crypt”和“cryptsetup”经常被混用或并用。或者说，这两者常常被用来指代同一个东西。如果要细说的话，“dm-crypt”是 Linux 内核提供的一个磁盘加密功能，而“cryptsetup”是一个命令行的前端（通过它来操作“dm-crypt”）。 “dm-crypt”在 Linux Kernel 2.6 的早期版本就被整合到内核中，距今已经10多年了。经过这么多年发展，至少能说明如下几点： 1. 它的开源代码足够成熟 2. 它提供的功能足够通用 3." />
    <meta name="og:image"
        content="https://opvlbqxurl.execute-api.ap-northeast-2.amazonaws.com/prod/random?keyword=programming&slug=扫盲 dm-crypt&amp;#8212;&amp;#8212;多功能 Linux 磁盘加密工具&amp;#65288;兼容 TrueCrypt 和 VeraCrypt&amp;#65289;" />
    <title> 扫盲 dm-crypt&amp;#8212;&amp;#8212;多功能 Linux 磁盘加密工具&amp;#65288;兼容 TrueCrypt 和 VeraCrypt&amp;#65289; | 编程随想镜像站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/css/blog.css" />
    
    <!-- plugins -->
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/bootstrap/bootstrap.min.css ">
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/themify-icons/themify-icons.css ">
    

</head>

<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/">Home</a>
        </div>
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/post/index.xml">RSS</a>
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(https://project-gutenberg.github.io/program-think/img/bg-blog.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                    扫盲 dm-crypt&amp;#8212;&amp;#8212;多功能 Linux 磁盘加密工具&amp;#65288;兼容 TrueCrypt 和 VeraCrypt&amp;#65289;
                    
                </h1>
                
            </div>
        </div>
    </section>

<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-12">
        <div class="tile is-child box">
            

            <div class="content">
                <p>　　很抱歉，又拖了好几天才更新博文。最近实在太忙了 :( 而且这篇博文的内容比较杂，整理起来也有点费时。 　　（本文发出后，俺顺便清理了博客管理界面的“留言垃圾箱”，里面有30多条“被 Google 误判为垃圾广告的留言”，刚才都已经恢复了）<br />
　　9月底，TrueCrypt 曝光了高危安全漏洞。于是俺在10月初写了<a href="https://program-think.blogspot.com/2015/10/VeraCrypt.html">一篇教程</a>，介绍 VeraCrypt 这个替代品——它可以完全覆盖 TrueCrypt 原有的功能，并且在安全方面还所有增强（比如用 PIM 来对抗“抗暴力破解”）。 　　那篇博文发出后，有些读者担心这个 VeraCrypt 本身是否可靠，是否会有后门。从目前 VeraCrypt 的口碑来看，这款工具应该还是比较靠谱滴！当然，俺无法向你担保 VeraCrypt 一定没有后门（谁都没法打这个包票）。 　　为了照顾那些“对安全性要求【特别高】的同学”，今天来介绍另一款磁盘加密工具——Linux 内核自带的“dm-crypt”。 　　另外，在本文的结尾部分，俺还会聊到：如何在【不使用】TrueCrypt/VeraCrypt 软件的情况下，挂载它们的加密盘。 　　既然是“扫盲”，本文主要面向那些不太懂技术的读者（技术菜鸟）。如今 Linux 已经比较普及了，有些技术菜鸟也开始玩 Linux。 　　如果你属于此类用户，并且你还比较关注隐私保护，希望用上磁盘加密工具。那么 Linux 内核自带的 dm-crypt 是一个不错的选择。 　　本文的主题，就是向技术菜鸟介绍 dm-crypt 的基本用法。 　　在某些技术文章中，“dm-crypt”和“cryptsetup”经常被混用或并用。或者说，这两者常常被用来指代同一个东西。如果要细说的话，“dm-crypt”是 Linux 内核提供的一个磁盘加密功能，而“cryptsetup”是一个命令行的前端（通过它来操作“dm-crypt”）。 　　“dm-crypt”在 Linux Kernel 2.6 的早期版本就被整合到内核中，距今已经10多年了。经过这么多年发展，至少能说明如下几点： 1. 它的开源代码足够成熟 2. 它提供的功能足够通用 3. 它在安全方面足够靠谱 　　先大致描述一下 dm-crypt 支持的功能以及相关特色。 　　目前 dm-crypt 支持如下几种加密格式（模式）。</p>

<p>　　<strong>1. LUKS（Linux Unified Key Setup）</strong></p>

<p>　　这是 dm-crypt 最常用的一种模式。在本文后续章节，俺会详细介绍。</p>

<p>　　<strong>2. Plain</strong></p>

<p>　　Plain 模式是提供给技术老手用的。如果你是技术菜鸟，就不用关心这个模式了；如果你是技术老鸟，请自己去查 dm-crypt 相关手册。</p>

<p>　　<strong>3. loop-AES</strong></p>

<p>　　loop-AES 是一款比较陈旧的 Linux 磁盘加密工具。dm-crypt 提供了对它的支持。 　　通常情况下，大伙儿【不需要】用到该模式。</p>

<p>　　<strong>4. TCRYPT</strong></p>

<p>　　在 cryptsetup 的【1.6.0】版本之后，开始提供对 TrueCrypt 加密盘的支持。“TCRYPT”就是“TrueCrypt”的缩写。 　　在该模式下，可以打开 TrueCrypt 和 VeraCrypt 的加密盘，并对盘中的文件进行读写。 　　请注意：这个模式并【没有】实现 TrueCrypt 和 VeraCrypt 的所有功能。比如修改密码和 keyfiles 的功能就没有。具体欠缺哪些功能，参见下一章节的对照表。 　　由于 dm-crypt 早已被整合到 Linux Kernel 中。因此，你无需额外安装它。 　　至于它的命令行前端（cryptsetup），大部分主流的发行版都会内置 cryptsetup 的软件包。 　　LVM（Logical Volume Manager）是 Linux 内核提供的另一个很有用的工具。比如用它来创建分区，将来可以随时调整分区大小；比如现有的硬盘空间用完了，可以另外加一块硬盘并且新加硬盘可以用来扩展现有分区。</p>

<p>　　LVM 和 dm-crypt 都是基于 Linux 内核的 <a href="https://en.wikipedia.org/wiki/Device_mapper">device mapper</a> 机制。因此两者可以很好地整合。比如你既可以玩“LVM over LUKS”；也可以玩“LUKS over LVM”。</p>

<p>　　有空的话，俺再单独写一篇关于 LVM 的扫盲（又是一个坑） 　　为了让大伙儿有个直观的认识，俺整理了如下的对照表。通过对比，你可以大致了解 dm-crypt 相对于“TrueCrypt和VeraCrypt”的优缺点。 　　再次提醒：dm-crypt 的 TCRYPT 模式，需要 cryptsetup 的版本号大于等于【1.6.0】才行。</p>

<p>LUKS 加密盘格式</p>

<p>TC 加密盘格式</p>

<p>功能特性</p>

<p>dm-crypt 的 LUKS 模式</p>

<p>dm-crypt 的 TCRYPT 模式</p>

<p>TrueCrypt</p>

<p>VeraCrypt</p>

<p>支持的操作系统</p>

<p>Linux</p>

<p>Linux</p>

<p>Windows Linux</p>

<p>Mac OS</p>

<p>Windows Linux</p>

<p>Mac OS</p>

<p>支持的加密算法类型</p>

<p>（内核 Crypto API）</p>

<p>AES Twofish</p>

<p>Serpent</p>

<p>AES Twofish</p>

<p>Serpent</p>

<p>AES Twofish Serpent Camellia</p>

<p>Kuznyechik</p>

<p>支持多重加密算法（多算法级联）</p>

<p>NO</p>

<p>AES–Twofish Serpent–AES Twofish–Serpent AES–Twofish–Serpent</p>

<p>Serpent–Twofish–AES</p>

<p>AES–Twofish Serpent–AES Twofish–Serpent AES–Twofish–Serpent</p>

<p>Serpent–Twofish–AES</p>

<p>AES–Twofish AES–Twofish–Serpent Camellia–Kuznyechik Camellia–Serpent Kuznyechik–AES Kuznyechik–Serpent–Camellia Kuznyechik–Twofish Serpent–AES Serpent–Twofish–AES</p>

<p>Twofish–Serpent</p>

<p>支持的哈希算法</p>

<p>RIPEMD-160 SHA1 SHA256</p>

<p>SHA512</p>

<p>RIPEMD-160 SHA-512</p>

<p>Whirlpool</p>

<p>RIPEMD-160 SHA-512</p>

<p>Whirlpool</p>

<p>RIPEMD-160 SHA-256 SHA-512 Whirlpool</p>

<p>Streebog</p>

<p>【创建】加密的物理分区</p>

<p>YES</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>【挂载】加密的物理分区</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>【创建】虚拟加密盘（virtual volume）</p>

<p>YES</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>【挂载】虚拟加密盘（virtual volume）</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>加密系统分区（引导时自解密）</p>

<p>YES（仅 Linux 系统分区）</p>

<p>NO</p>

<p>YES（仅 Windows 系统分区）</p>

<p>YES（仅 Windows 系统分区）</p>

<p>支持“密码”的认证方式</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>支持“Keyfiles”的认证方式</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>加密系统分区支持 Keyfiles</p>

<p>YES（仅 Linux 系统分区）</p>

<p>NO</p>

<p>NO</p>

<p>NO</p>

<p>修改密码或 Keyfiles</p>

<p>YES</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>【创建】隐藏卷（hidden volume）</p>

<p>NO</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>【挂载】隐藏卷（hidden volume）</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>操作外层卷时，对隐藏卷写保护</p>

<p>NO</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>自定义“生成密钥的迭代次数”</p>

<p>YES</p>

<p>YES（cryptsetup ≥ 2.0.0）</p>

<p>NO</p>

<p>YES（PIM 功能，版本 ≥ 1.12）</p>

<p>加密格式的模糊性</p>

<p>NO</p>

<p>YES</p>

<p>YES</p>

<p>YES</p>

<p>　　在使用 <code>cryptsetup</code> 命令行进行操作之前，建议你先掌握如下的技能：</p>

<blockquote>
<p>如何对硬盘分区（相关的命令行是 <code>fdisk</code>）<br />
如何创建文件系统（相关的命令行是 <code>mkfs.ext4</code> 等）<br />
如何挂载/卸载文件系统（相关的命令行是 <code>mount umount</code>）<br />
如何显示已挂载的文件系统（相关的命令行是 <code>df</code>）</p>
</blockquote>

<p>　　上述这几个命令都比较简单，可以自己用 <code>man</code> 命令查一下帮助。会洋文的话，应该能看懂；就算你不懂洋文，Google 一下也可以查到这几个常用命令的语法。<br />
　　说完预备知识，开始来介绍 <code>cryptsetup</code> 的基本用法。<br />
　　提醒一下：需要使用管理员权限（比如 <code>root</code>）来运行 <code>cryptsetup</code> 相关命令。 　　使用如下命令行查看版本号。</p>

<p>cryptsetup &ndash;version</p>

<p>　　因为 dm-crypt/cryptsetup 的某些新功能，只有新版本才提供。比如 cryptsetup 的版本号必须大于等于【1.6.0】才能支持 TrueCrypt 的加密盘格式。 　　如果你要用到这些新功能，先看一下版本号，以确保已经支持。 　　使用如下命令查看 dm-crypt/cryptsetup 针对不同“加密算法”和“散列算法”的性能指标。</p>

<p>cryptsetup benchmark</p>

<p>　　前面提到 dm-crypt/cryptsetup 支持的几种加密盘格式。作为扫盲教程，本文只介绍如何创建 LUKS 格式加密盘。 　　另外，dm-crypt/cryptsetup 只能用来打开 TrueCrypt 或 VeraCrypt 的加密盘，但是【无法】创建。 　　创建（格式化） LUKS 加密盘的命令，大致写法如下：</p>

<p>cryptsetup 命令参数 luksFormat 物理设备或逻辑设备</p>

<p>　　运行该命令之后，首先警告你，格式化会导致原有数据被覆盖。如果你确实要格式化，需要输入【大写】的 YES 进行确认。 　　然后会提示你输入两次密码（passphrase）。 　　输入完密码，还要再稍等片刻（创建加密盘需要时间，具体的时长取决于加密盘的大小以及相关的加密参数）。 　　上述写法中的【相关参数】是可以不写的。如果不写，则 cryptsetup 会采用相应的默认值。对于安全性要求较高的同学，【不要】使用默认值，要根据自己的需求指定相关的参数。</p>

<p>　　当你使用 <code>luksFormat</code> 进行格式化的时候，下面是几个常用参数以及俺推荐的参数值：</p>

<p>参数名称</p>

<p>含义</p>

<p>推荐值</p>

<p>备注</p>

<p>--cipher</p>

<p>加密方式</p>

<p>aes-xts-plain64</p>

<p>AES 加密算法搭配 XTS 模式 关于 XTS 模式，可以参见之前的博文：</p>

<p>《<a href="https://program-think.blogspot.com/2013/08/truecrypt-1.html">TrueCrypt 使用经验[1]：关于加密算法和加密盘的类型</a>》</p>

<p>--key-size</p>

<p>密钥长度</p>

<p>512</p>

<p>因为 XTS 模式需要两对密钥，每个的长度是256</p>

<p>--hash</p>

<p>散列算法</p>

<p>sha512</p>

<p>N/A</p>

<p>--iter-time</p>

<p>迭代时间</p>

<p>最好大于10000</p>

<p>单位是毫秒。该值越大，暴力破解越难；但是你在打开加密盘时也要等待更久</p>

<p>　　下面给一个具体的例子——用 LUKS 方式创建（格式化）加密盘，该加密盘位于 <code>/dev/sda2</code> 分区</p>

<p>cryptsetup &ndash;cipher aes-xts-plain64 &ndash;key-size 512 &ndash;hash sha512 &ndash;iter-time 10000 luksFormat /dev/sda2</p>

<p>　　dm-crypt/cryptsetup 可以打开前面提及的各种格式的加密（只要是它支持的格式，就可以打开）。 　　命令行大致的写法如下：</p>

<p>cryptsetup open &ndash;type 类型名 已加密的物理设备或逻辑设备 映射名</p>

<p>　　上述命令行中的 <code>open --type 类型名</code>，也可以改用某种简写形式。 　　比如下面这个命令：</p>

<p>cryptsetup open &ndash;type luks 已加密的物理设备或逻辑设备 映射名</p>

<p>　　其实等价于如下：</p>

<p>cryptsetup luksOpen 物理设备或逻辑设备 映射名</p>

<p>　　下面举个具体的例子：<br />
　　假设物理分区 <code>/dev/sda2</code> 采用 LUKS 加密，那么你可以用如下命令打开（命令中的 <code>xxx</code> 是映射名，你可以换成其它单词）</p>

<p>cryptsetup luksOpen /dev/sda2 xxx</p>

<p>　　执行上述命令后，原有的加密分区 <code>/dev/sda2</code> 就被解密并映射到 <code>/dev/mapper/xxx</code><br />
　　打开加密盘之后，你就【不要】再去操作 <code>/dev/sda2</code> 了，而应该去操作 <code>/dev/mapper/xxx</code> 　　当你已经打开某个加密盘之后，可以用如下命令查看该加密盘的状态。</p>

<p>cryptsetup status 映射名</p>

<p>　　当你已经打开某个加密盘之后，可以用如下命令关闭该加密盘。</p>

<p>cryptsetup close 映射名</p>

<p>　　与 <code>open</code> 类似，cryptsetup 也对 <code>close</code> 提供了相应的别名（比如：<code>luksClose 和 tcryptClose</code>）<br />
　　实际上 cryptsetup 是根据已经打开的加密盘的 header 来判断该加密盘的类型。所以上述别名的意义不大。比如说，你对某个 TrueCrypt 的加密盘使用 <code>luksClose</code>，依然可以正确关闭，不会出错。<br />
　　首先，你要准备一个物理分区，用来加密。</p>

<p>　　【<strong>你必须确保该分区上的数据是没用的</strong>】。因为待会儿要对该分区进行格式化操作，该分区上原有的数据会被破坏掉。</p>

<p>　　在下面的介绍中，俺以 <code>/dev/sda2</code> 来进行举例。你实际使用的分区，可能会有所差异（具体取决于你的分区情况）。 　　使用前面章节提及的参数，对上述物理分区进行加密。得到一个加密分区。</p>

<p>cryptsetup &ndash;cipher aes-xts-plain64 &ndash;key-size 512 &ndash;hash sha512 &ndash;iter-time 10000 luksFormat /dev/sda2</p>

<p>　　使用如下命令打开上述的加密分区，使用的映射名是 <code>xxx</code>（你也可以改用其它单词）。</p>

<p>cryptsetup luksOpen /dev/sda2 xxx</p>

<p>　　打开之后，该虚拟盘会被映射到 /dev/mapper/xxx 　　你可以用如下命令看到：</p>

<p>ls /dev/mapper/</p>

<p>　　由于加密分区已经打开并映射到 <code>/dev/mapper/xxx</code> 你可以在 <code>/dev/mapper/xxx</code> 之上创建文件系统。命令如下（文件系统类型以 ext4 为例）</p>

<p>mkfs.ext4 /dev/mapper/xxx</p>

<p>　　创建完文件系统之后，你还需要挂载该文件系统，才能使用它。挂载的步骤如下。</p>

<p>　　首先，你要先创建一个目录，作为【挂载点】。俺把“挂载点”的目录设定为 <code>/mnt/xxx</code>（当然，你可以用其它目录作为挂载点）。</p>

<p>mkdir /mnt/xxx</p>

<p>　　创建好“挂载点”对应的目录，下面就可以进行文件系统的挂载。</p>

<p>mount /dev/mapper/xxx /mnt/xxx</p>

<p>　　挂载好文件系统，用如下命令查看，就可以看到你刚才挂载的文件系统。</p>

<p>df -hT</p>

<p>　　接下来，你就可以通过 <code>/mnt/xxx</code> 目录去访问该文件系统。当你往 <code>/mnt/xxx</code> 下面创建下级目录或下级文件，这些东东将被存储到加密分区上。 　　当你使用完，要记得退出。包括下面两步： 　　卸载文件系统</p>

<p>umount /mnt/xxx</p>

<p>　　关闭加密盘</p>

<p>cryptsetup close xxx</p>

<p>　　在前一个章节，已经介绍了“对物理分区的加密”。其实 cryptsetup 也可以支持虚拟加密盘（逻辑加密盘）——类似于 TrueCrypt 那样。<br />
　　考虑到某些读者没有看过《<a href="https://program-think.blogspot.com/2013/08/truecrypt-1.html">TrueCrypt 使用经验[1]：关于加密算法和加密盘的类型</a>》，俺再次唠叨一下：所谓的“虚拟加密盘”，就是说这个盘并【不是】对应物理分区，而是对应一个虚拟分区（逻辑卷）。这个虚拟分区，说白了就是一个大文件。虚拟分区有多大，这个文件就有多大。<br />
　　“虚拟加密盘”的一个主要好处在于——可以拷贝复制。比如你可以在不同的机器之间复制这个虚假分区对应的大文件。甚至可以把这个大文件上传到云端（网盘）进行备份——这么干的好处参见《<a href="https://program-think.blogspot.com/2013/07/online-backup-virtual-encrypted-disk.html">文件备份技巧：组合“虚拟加密盘”与“网盘”</a>》。<br />
　　下面用 <code>dd</code> 命令创建 1GB（1024MB）的大文件，该文件位于 <code>/root/luks.vol</code> 路径。当然，你也可以指定其它的文件大小或其它的文件路径。</p>

<p>dd if=/dev/zero of=/root/luks.vol bs=1M count=1024</p>

<p>　　（dd 命令是一个牛逼命令，之前在《<a href="https://program-think.blogspot.com/2013/12/create-bootable-usb-stick-from-iso.html">如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）</a>》介绍过该命令）</p>

<p>　　经某个热心读者提醒，还可以使用 <code>fallocate</code> 命令创建容器文件。对于特别大的容器文件，性能【高于】<code>dd</code> 命令。</p>

<p>　　以下示例通过 <code>fallocate</code> 【瞬间】创建一个 64GB 的大文件。</p>

<p>fallocate -l 64G /root/luks.vol</p>

<p>　　使用前面章节提及的参数，对上述文件容器进行加密。得到一个虚拟的加密盘。</p>

<p>cryptsetup &ndash;cipher aes-xts-plain64 &ndash;key-size 512 &ndash;hash sha512 &ndash;iter-time 10000 luksFormat /root/luks.vol</p>

<p>　　使用如下命令打开上述的文件容器，使用的映射名是 xxx（你也可以改用其它单词）。</p>

<p>cryptsetup luksOpen /root/luks.vol xxx</p>

<p>　　打开之后，该虚拟盘会被映射到 /dev/mapper/xxx 　　你可以用如下命令看到：</p>

<p>ls /dev/mapper/</p>

<p>　　由于加密盘已经打开并映射到 <code>/dev/mapper/xxx</code> 你可以在 <code>/dev/mapper/xxx</code> 之上创建文件系统。命令如下（文件系统类型以 ext4 为例）</p>

<p>mkfs.ext4 /dev/mapper/xxx</p>

<p>　　创建完文件系统之后，你还需要挂载该文件系统，才能使用它。挂载的步骤如下。</p>

<p>　　首先，你要先创建一个目录，作为【挂载点】。俺把“挂载点”的目录设定为 <code>/mnt/xxx</code>（当然，你可以用其它目录作为挂载点）。</p>

<p>mkdir /mnt/xxx</p>

<p>　　创建好“挂载点”对应的目录，下面就可以进行文件系统的挂载。</p>

<p>mount /dev/mapper/xxx /mnt/xxx</p>

<p>　　挂载好文件系统，用如下命令查看，就可以看到你刚才挂载的文件系统。</p>

<p>df -hT</p>

<p>　　接下来，你就可以通过 <code>/mnt/xxx</code> 目录去访问该文件系统。当你往 <code>/mnt/xxx</code> 下面创建下级目录或下级文件，这些东东将被存储到该虚拟加密盘上。 　　当你使用完，要记得退出。包括下面两步： 　　卸载文件系统</p>

<p>umount /mnt/xxx</p>

<p>　　关闭加密盘</p>

<p>cryptsetup close xxx</p>

<p>　　其实这个概念，在当年扫盲 TrueCrypt 的教程中（《<a href="https://program-think.blogspot.com/2011/05/recommend-truecrypt.html">TrueCrypt——文件加密的法宝</a>》）已经有提及。今天俺再重复罗嗦一下。 　　传统的“密码认证”用的是一串密不示人的字符串作为认证因素。密码的缺点： 1. 当你密码设置得比较短，容易被暴力破解。 2. 不好记。尤其当你为了防范暴力破解，把密码设置得很复杂，于是就更不好记了。 　　而“keyfile 认证”就是用一个文件来替代密码，可以解决密码的上述两个缺点。 　　用信息学的术语来讲就是：文件内容的“熵值”越大，越适合作 keyfile。换用通俗的人话来讲就是：文件内容越紊乱越随机，就越适合。 　　通常而言，二进制可执行文件（比如 exe）、图片文件（比如 JPG、PNG、GIF）、视频文件，都可以用来作 keyfile。 　　对于 Linux 的用户，可以用如下命令生产一个【内容完全随机】的文件，作为 keyfile 使用。</p>

<p>dd if=/dev/urandom of=放置keyfile的文件路径 bs=1k count=64</p>

<p>　　（上述命令生产的文件大小是 64KB，你可以自行设定其它尺寸，但是【不要小于】 1KB） 　　另外，【不建议】用纯文本文件作 keyfile——因为纯文本文件的“熵值”通常都不够大。 　　在继续介绍 keyfile 之前，稍微聊点预备知识。 　　LUKS 格式的加密盘，默认会提供8个“Key Slot”（编号从0到7）。每个“Key Slot”好比是一个独立的钥匙——都可以用来打开这个 LUKS 加密盘。 　　你可以用如下命令，查看某个 LUKS 加密盘的“Key Slot”。</p>

<p>cryptsetup luksDump 已加密的物理设备或逻辑设备</p>

<p>　　如果你刚才已经尝试过创建一个 LUKS 加密盘，用了这个命令之后，你会发现8个“Key Slot”中，头一个（编号为0的那个）已经被用掉了（显示为“ENABLED”），其它7个还没用（显示为“DISABLED”）。因为你刚才创建加密盘的时候，已经设置过一次密码，所以用掉了一个“Key Slot”。 　　明白了“Key Slot”之后，咱们可以开始给 LUKS 加密盘增加新的“Key Slot”。 　　采用如下命令，可以指定某个文件作为 keyfile，并指派为某个 LUKS 加密盘的认证因素。</p>

<p>cryptsetup luksAddKey 已加密的物理分区或虚拟盘 所用keyfile的路径</p>

<p>　　再次使用前一小节提及的 <code>luksDump</code> 查看一下，你会发现：又有一个“Key Slot”被用掉了。 　　如果你执行完前一个小节的步骤（设定了 keyfile），接下来就可以用如下命令打开该 LUKS 加密盘。</p>

<p>cryptsetup &ndash;key-file 所用keyfile的路径 luksOpen 已加密的物理分区或虚拟盘 映射名</p>

<p>　　（此时，你既可以用密码打开，也可以用 keyfile 打开） 　　采用如下命令，可以删除某个 LUKS 加密盘的“Key Slot”。</p>

<p>cryptsetup luksKillSlot 已加密的物理分区或虚拟盘 Slot的编号</p>

<p>　　（再次提醒：编号是从0到7，头一个 Slot 的编号是0）<br />
　　再次使用前一小节提及的 <code>luksDump</code> 查看一下，你会发现：某个“Key Slot”被删除了。</p>

<p>　　在前面的“功能概述”中提及：dm-crypt 软件的 <code>cryptsetup</code> 命令可以用来打开 TrueCrypt/VeraCrypt 加密盘。 　　命令行的大致写法如下：</p>

<p>cryptsetup open &ndash;type tcrypt 已加密的物理分区或虚拟盘 映射名</p>

<p>　　也可以使用简写的方式如下：</p>

<p>cryptsetup tcryptOpen 已加密的物理分区或虚拟盘 映射名</p>

<p>　　（再次唠叨一下：<code>cryptsetup</code> 的版本号必须——大于等于【1.6.0】才能兼容 TrueCrypt/VeraCrypt 加密盘） 　　在 TCRYPT 模式下，有一些相关的参数，简要说明如下：</p>

<p>参数名</p>

<p>参数值</p>

<p>说明</p>

<p>--tcrypt-hidden</p>

<p>无</p>

<p>打开隐藏卷，需要追加该参数</p>

<p>--tcrypt-system</p>

<p>无</p>

<p>打开加密的系统分区，需要追加该参数</p>

<p>--readonly</p>

<p>无</p>

<p>以“只读”方式打开加密分区，需要追加该参数</p>

<p>--key-file</p>

<p>key file 路径</p>

<p>如果该加密盘用到了“keyfiles”认证，需要追加该参数</p>

<p>--veracrypt</p>

<p>无</p>

<p>对 VeraCrypt 格式的加密盘，必须追加该参数<br />
（cryptsetup 版本号 ≥ 1.6.7 才支持该参数）</p>

<p>--veracrypt-pim</p>

<p>PIM 值</p>

<p>如果 VeraCrypt 格式的加密盘设定了 PIM 值，必须追加该参数<br />
（cryptsetup 版本号 ≥ 2.0.0 才支持该参数）</p>

<p>　　关于 VeraCrypt 的补充说明：</p>

<p>　　<code>cryptsetup</code> 命令的版本号必须【≥ 1.6.7】才能打开 VeraCrypt 的加密盘。截止俺写这篇博文时，还【不】支持 VeraCrypt 的 PIM 功能。</p>

<p>　　本文发出之后又过了4年（2019年8月），<code>cryptsetup</code> 命令升级到【2.0.0】版本终于支持 VeraCrypt 加密盘的 PIM 功能啦！<br />
　　（关于 PIM 功能的详细介绍，请参见《<a href="https://program-think.blogspot.com/2015/10/VeraCrypt.html">扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品</a>》）<br />
　　在本文开头，俺已经说了——这篇教程面向技术菜鸟。而“加密系统分区”对技术菜鸟来讲，有一定难度。万一没搞好，可能会把系统搞坏掉（导致 Linux 系统无法启动）。 　　咋办捏？俺帮大伙儿想了一招比较简单的玩法——在安装系统的时候，就配置好“加密的系统分区”（甚至直接配置为“全盘加密”）。 　　能否使用这招，要看具体的 Linux 发行版，在安装过程中是否提供相应的配置界面。如果俺没记错的话，如下几个主流的发行版，是可以在安装过程中加密系统分区或全盘加密的。（如果你觉得俺列举的发行版，有遗漏，欢迎到博客留言进行补充）</p>

<blockquote>
<p>Debian Fedora Ubuntu Linux Mint CentOS</p>

<p>RedHat Enterprise Linux（RHEL）</p>
</blockquote>

<p>　　由于不同的发行版，安装界面各不相同，所以俺就偷懒一下，不提供截图了。 　　大体上，这些发行版的安装过程，都有一个步骤是“硬盘分区”。在这个步骤，会提供相关的“加密选项”。</p>

<p>　　对于想要进行全盘加密的同学，装系统过程中进行分区的时候，要把 <code>/boot</code> 单独分一个区。并且这个分区是【不能】加密的——因为 <code>/boot</code> 要用来放置引导管理器与内核。</p>

<p>　　从理论上讲：任何一种磁盘加密工具，（在不借助外部机制的情况下）都【不可能】实现真正的“自启动全盘加密”。 　　为啥捏？因为要想【自启动】，必须要有一个引导程序，至少这个引导程序不能加密（引导程序如果被加密了，就无法引导了）。所以，凡是能够实现“自启动全盘加密”的，其【引导程序】都是明文的（无加密的） 　　比如 TrueCrypt 和 VeraCrypt 进行全盘加密，都会替换原有的主引导扇区的内容，在里面放入一段代码。这段代码会在开机启动的时候，提示你输入密码，然后用你输入的密码进行解密。</p>

<p>　　对于 dm-crypt 的全盘加密，除了“主引导扇区”【没有】加密，还包括 <code>/boot</code> 分区也【没有】加密（因为启动管理器放置在 <code>/boot</code> 分区）。</p>

<p>　　如前所述，<strong>这些【没有加密】的部分，会成为攻击者瞄准的弱点</strong>。 　　攻击举例： 　　如果某个攻击者可以物理接触你的电脑，此人完全可以把你硬盘上的引导程序替换为一个假的引导程序。当你开机启动的时候，这个【假的】引导程序照样会提示你输入解密的密码。如此一来，你的密码就泄漏了。 　　常规的防范措施有如下几种：</p>

<p>　　<strong>方法1——采用 BIOS 提供的“硬盘口令”功能</strong></p>

<p>　　一般而言，台式机没有这个功能；大部分商用笔记本有这个功能。 　　这个功能的安全性如何，要看具体的笔记本品牌（不同厂商的实现，可能不一样，因此安全性也不一样）。如果这个功能比较靠谱，就可以防止攻击者在你不知情的情况下，替换你硬盘上的引导程序。</p>

<p>　　<strong>方法2——采用外部存储介质进行引导</strong></p>

<p>　　简而言之，就是把引导程序放到【可引导的】外部介质（比如 U盘、SD卡、MMC卡）。先用外部介质进行引导，然后通过外部介质中的引导程序，提示你输入密码，然后解密硬盘，最后再启动硬盘上的操作系统。 　　对于“U盘/SD卡/MMC卡”而言，因为可以随身携带或隐藏在某处，被攻击者物理接触的风险会降低。 　　对于 TrueCrypt/VeraCrypt【没法】用这招。而对于 dm-crypt，可以用这招。这种玩法略显复杂，不适合菜鸟。考虑到本文是“扫盲性质”的教程，暂且不提。</p>

<p>　　<strong>方法3——把【整个系统】安装到外部存储介质</strong></p>

<p>　　这种玩法就是把【整个操作系统】都安装到外部存储介质（比如 U盘、SD卡、MMC卡）。开机时，需要先插入外部存储介质，启动整个操作系统。然后在这个操作系统中内置的 dm-crypt 挂载加密的硬盘。 　　对于“U盘/SD卡/MMC卡”而言，因为可以随身携带或隐藏在某处，被攻击者物理接触的风险会降低。 　　很多主流的 Linux 发行版，默认提供了 Live CD 的功能（也就是用光盘直接启动出一个【可用】的 Linux 环境）</p>

<p>　　对这类发行版，你可以用工具把 Live CD 的 ISO 镜像文件“烧制”到 U盘/SD卡/MMC卡。然后就可以用来启动电脑。具体的教程参见《<a href="https://program-think.blogspot.com/2013/12/create-bootable-usb-stick-from-iso.html">如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）</a>》。</p>

<p>　　在本文结束前，俺最后聊一下如何混用 dm-crypt 和 TrueCrypt/VeraCrypt。<br />
　　在本文开头部分给出了一个“功能对比”的清单，从中可以看出 dm-crypt 和 TrueCrypt/VeraCrypt <strong>各有独到之处</strong>。 　　比如 dm-crypt 可以用来加密 Linux 的系统分区（root filesystem），而 TrueCrypt 和 VeraCrypt 都做不到；</p>

<p>　　反之，TrueCrypt 和 VeraCrypt 提供了“隐藏卷”的功能。可以用该功能来实现“Plausible Deniability”（介绍参见“<a href="https://program-think.blogspot.com/2013/10/truecrypt-4.html">这里</a>”），而 dm-crypt 做不到这点。</p>

<p>　　因此，有必要组合这两者。 　　截止俺写本文的时候，TrueCrypt 的 Linux 版本【尚未发现】高危漏洞，所以你如果要继续使用 Linux 下的 TrueCrypt，也是可以的。 　　但是考虑到 TrueCrypt 已经停止维护，长远来讲，还是建议用“dm-crypt + VeraCrypt”这个组合进行混用。</p>

<p>　　另外，VeraCrypt 增加了 PIM 功能来对抗暴力破解。对那些安全要求非常高的同学，这个“PIM 功能”也是有吸引力的。（关于 PIM 功能，参见《<a href="https://program-think.blogspot.com/2015/10/VeraCrypt.html">扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品</a>》）</p>

<p>　　首先用 dm-crypt/cryptsetup 对系统分区（root filesystem）进行加密 或者 实现全盘加密。（具体玩法参见前面的章节）</p>

<p>　　然后在已经加密的分区中，创建 TrueCrypt/VeraCrypt 的虚拟加密盘，并使用隐藏卷的功能。（如何使用隐藏卷，参见《<a href="https://program-think.blogspot.com/2013/10/truecrypt-4.html">TrueCrypt 使用经验[4]：关于隐藏卷的使用和注意事项</a>》）</p>

<p>　　把你最敏感最重要的数据，存储在【隐藏卷】中。</p>

<p>　　假设将来有一天，你受到胁迫，你可以交出 dm-crypt 的加密密码。然后利用隐藏卷这个功能，来施展【Plausible Deniability】这个技巧，迷惑胁迫你的人。关于该技巧的使用场景，参见<a href="https://program-think.blogspot.com/2011/05/recommend-truecrypt.html">这篇博文</a>里面的◇Plausible Deniability章节。</p>

<p>　　本来这个话题应该是放到<a href="https://program-think.blogspot.com/2015/10/VeraCrypt.html">之前那篇博文</a>来聊的。但是在写前面那篇博文的时候，俺还没有扫盲“dm-crypt/cryptsetup”。于是就把这个话题留到今天这篇。 　　从俺博客的读者留言中，可以看出某些人对这两款工具都不太放心。 　　TrueCrypt 　　虽然历史悠久，口碑极好。但是官网已经宣布“停止维护”。而且上个月底（9月底）刚曝光了 Windows 版本的高危漏洞。 　　VeraCrypt 　　因为这个开源项目的历史比较短，有些同学担心这个项目会不会是一个蜜罐项目。 　　先不管这两个软件在【代码层面】是否有后门，咱们先来说【加密盘的格式】。 　　“加密盘格式”与“程序代码”不同。“加密盘格式”是很少变化的（基本是静态的），而“程序代码”会随着软件版本的升级，而不断发生变化——有可能这个版本没有后门，但是下一个版本就被植入后门。 　　“TrueCrypt 的加密盘格式”已经被很多安全专家研究过。包括这两年安全界发起了对 TrueCrypt 的安全审计，其中一项工作就是：评估加密盘的格式。 　　到目前为止，至少【没有】发现该格式有明显的后门或弱点。</p>

<p>　　综上所述，俺认为 <strong>TrueCrypt 的加密盘格式是可靠的（可信的）</strong>。</p>

<p>　　而 VeraCrypt 的加密盘格式，跟 TrueCrypt 的格式【<strong>几乎完全一样</strong>】——俺专门看过这两者的技术规范文档，加密盘头部（header）的结构【完全一样】，仅有的差异在于某个标志位（从 TrueCrypt 的标志改为 VeraCrypt 的标志）。</p>

<p>　　因此，<strong>VeraCrypt 的加密盘格式，也是可靠的（可信的）</strong>。 　　基于上述分析，有一个策略可以帮你规避 TrueCrypt/VeraCrypt【软件本身】潜在的后门。具体步骤如下： 　　1.</p>

<p>　　你在某个<strong>操作系统虚拟机</strong>中，安装好 TrueCrypt 或 VeraCrypt。</p>

<p>　　2. 　　使用虚拟机中的 TrueCrypt 或 VeraCrypt 帮你创建【虚拟】加密盘。 　　3. 　　把创建好的【虚拟】加密盘 copy 到你的 Linux 环境中，用 dm-crypt 打开加密盘进行使用。 　　4. 　　如果需要修改加密盘的密码或 keyfile，再把【虚拟】加密盘 copy 回操作系统虚拟机中，用 TrueCrypt 或 VeraCrypt 修改密码或 keyfile。 　　基于上述步骤，你的 Linux 系统中完全不会运行 TrueCrypt 或 VeraCrypt，但是又可以享受这两款软件的强大功能（比如“隐藏卷”、比如“多重加密算法”）。 　　代价就是：操作步骤稍嫌繁琐（需要 copy 虚拟加密盘）。这也是没办法滴——“安全性”和“易用性”通常都是矛盾的。</p>

<p><strong>俺博客上，和本文相关的帖子（需翻墙）</strong>：</p>

<p>《<a href="https://program-think.blogspot.com/2019/02/Use-Disk-Encryption-Anti-Computer-Forensics.html">如何用“磁盘加密”对抗警方的【取证软件】和【刑讯逼供】，兼谈数据删除技巧</a>》<br />
《<a href="https://program-think.blogspot.com/2015/10/VeraCrypt.html">扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品</a>》<br />
《<a href="https://program-think.blogspot.com/2011/05/recommend-truecrypt.html">TrueCrypt——文件加密的法宝</a>》<br />
《<a href="https://program-think.blogspot.com/2013/08/truecrypt-1.html">TrueCrypt 使用经验[1]：关于加密算法和加密盘的类型</a>》<br />
《<a href="https://program-think.blogspot.com/2013/08/truecrypt-2.html">TrueCrypt 使用经验[2]：关于加密盘的密码认证和 KeyFiles 认证</a>》<br />
《<a href="https://program-think.blogspot.com/2013/08/truecrypt-3.html">TrueCrypt 使用经验[3]：关于加密盘的破解和防范措施</a>》<br />
《<a href="https://program-think.blogspot.com/2013/10/truecrypt-4.html">TrueCrypt 使用经验[4]：关于隐藏卷的使用和注意事项</a>》<br />
《<a href="https://program-think.blogspot.com/2020/06/Linux-Logical-Volume-Manager.html">扫盲 Linux 逻辑卷管理（LVM）——兼谈 RAID 以及“磁盘加密工具的整合”</a>》<br />
《<a href="https://program-think.blogspot.com/2011/05/file-encryption-overview.html">文件加密的扫盲介绍</a>》<br />
《<a href="https://program-think.blogspot.com/2013/07/online-backup-virtual-encrypted-disk.html">文件备份技巧：组合“虚拟加密盘”与“网盘”</a>》<br />
《<a href="https://program-think.blogspot.com/2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html">扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”</a>》<br />
《<a href="https://program-think.blogspot.com/2013/12/create-bootable-usb-stick-from-iso.html">如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）</a>》</p>

            </div>
            
        </div>
    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <br><br>
            <span>友链：<a href="https://program-think.blogspot.com/">编程随想的博客</a>
            <span>友链：<a href="http://www.xys.org/">新语丝</a>
                <span> </span><a href="https://twitter.com/fangshimin">方舟子 Twitter</a>
            </span>
            <br><br>
            Copyright &copy; 编程随想镜像站 2022
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
</body>

</html>