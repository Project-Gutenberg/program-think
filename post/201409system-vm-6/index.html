<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../post/index.xml">
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@SpeechFreedomCN">
    <meta name="twitter:creator" content="@SpeechFreedomCN">
    <meta name="og:title" content=" 扫盲操作系统虚拟机[6]&amp;#65306;如何优化运行速度&amp;#65311; | 编程随想镜像站 " />
    <meta name="og:description" content="前几天聊到了对付流氓软件的几个招数，其中最管用的一招是“操作系统虚拟机”。那篇博文发出后，有几个读者在博客留言中抱怨说：用了虚拟机之后，系统太卡了。所以今天来普及一些虚拟机的“运行速度优化”。
本文重点介绍【同时运行多个 VM 的速度优化】。俺会从“硬件选型”和“软件设置”两个角度分别来聊。如果你是第一次看本系列，建议你先看完前面几篇，再看本文。
在虚拟机的速度优化中，“虚拟化技术”是非常重要滴，可惜又少有人了解。所以俺把它放在本文第一个章节。
“虚拟化技术”全称是“x86 硬件虚拟化技术”，维基百科的解释在“这里”。为了打字省力，以下简称“VT”。 该技术是在【硬件】层面额外提供一些机制，这些机制仅仅用于“虚拟化”方面。如果你的电脑不是用来跑“虚拟机”，VT 技术对你而言毫无用处。
　为啥要在硬件层面额外提供这样一种技术捏？因为 x86 的体系结构，天生就【不适合】用来搞“操作系统虚拟化”（个中缘由，在本文评论区有相关讨论，这里就不细谈了）但是最近10多年来，“虚拟化”是大势所趋。所以 Intel 和 AMD 都在自家的芯片上提供了适合“虚拟化”的扩展机制。对 Intel 芯片而言，称之为“Intel-VT”（也叫“VT-x”）；对 AMD 芯片而言，称之为“AMD-V”。
　请注意，VT 只在部分型号的芯片上提供。也就是说，不论是 Intel 还是 AMD，都只有某些型号的芯片是支持 VT 滴。 如果要从原理上阐述 VT 的用处，需要涉及到 x86 架构的设计及其缺陷，说来话长啊。考虑到篇幅，俺只举几个例子。 举例1：
　有了 VT 之后，如果 Guest OS 中需要执行 CPU 的特权指令，虚拟机软件可以利用 VT 原生支持（硬件层面搞定）；如果没有 VT，碰到这种情况就只能靠软件模拟运行（靠软件模拟，效率会差很多！）。
　很多同学抱怨电脑跑 VM 太慢，其中一部分人的原因就是——CPU【不】支持 VT。 举例2： 有了 VT 之后，你可以在“32位”的 Host OS 里面虚拟出“64位”的 Guest OS；若没有 VT 支持，就无法在“32位”上虚拟“64位”。 首先，你应该去查一下自己的电脑是啥型号的，然后 Google 一下该型号的硬件配置，通常都可以在那些电脑行情网站（比如：太平洋电脑网、中关村在线）上找到该型号使用的 CPU 规格。在 CPU 规格中，通常就会提到这款 CPU 是否支持 VT。万一在 CPU 规格中没有提及是否支持 VT，你可以根据该 CPU 的详细型号，再到 Intel 或 AMD 的官网上查，肯定能查到相关说明。 假如你查到自己的 CPU 是支持 VT 的，还没完。你还得到操作系统里面检验一下，看 VT 在操作系统层面是否可见。" />
    <meta name="og:image"
        content="https://opvlbqxurl.execute-api.ap-northeast-2.amazonaws.com/prod/random?keyword=programming&slug=扫盲操作系统虚拟机[6]&amp;#65306;如何优化运行速度&amp;#65311;" />
    <title> 扫盲操作系统虚拟机[6]&amp;#65306;如何优化运行速度&amp;#65311; | 编程随想镜像站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/css/blog.css" />
    
    <!-- plugins -->
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/bootstrap/bootstrap.min.css ">
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/themify-icons/themify-icons.css ">
    

</head>

<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/">Home</a>
        </div>
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/post/index.xml">RSS</a>
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(https://project-gutenberg.github.io/program-think/img/bg-blog.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                    扫盲操作系统虚拟机[6]&amp;#65306;如何优化运行速度&amp;#65311;
                    
                </h1>
                
            </div>
        </div>
    </section>

<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-12">
        <div class="tile is-child box">
            

            <div class="content">
                <p>　　前几天聊到了<a href="https://program-think.blogspot.com/2014/08/privacy-protection-9.html">对付流氓软件的几个招数</a>，其中最管用的一招是“操作系统虚拟机”。那篇博文发出后，有几个读者在博客留言中抱怨说：用了虚拟机之后，系统太卡了。所以今天来普及一些虚拟机的“运行速度优化”。<br />
　　本文重点介绍【同时运行多个 VM 的速度优化】。俺会从“硬件选型”和“软件设置”两个角度分别来聊。如果你是第一次看<a href="https://program-think.blogspot.com/2012/10/system-vm-0.html">本系列</a>，建议你先看完前面几篇，再看本文。<br />
　　在虚拟机的速度优化中，“虚拟化技术”是非常重要滴，可惜又少有人了解。所以俺把它放在本文第一个章节。<br />
　　“虚拟化技术”全称是“x86 硬件虚拟化技术”，维基百科的解释在“<a href="https://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96">这里</a>”。为了打字省力，以下简称“VT”。 　　该技术是在【硬件】层面额外提供一些机制，这些机制仅仅用于“虚拟化”方面。如果你的电脑不是用来跑“虚拟机”，VT 技术对你而言毫无用处。</p>

<p>　　为啥要在硬件层面额外提供这样一种技术捏？因为 <strong>x86 的体系结构，天生就【不适合】用来搞“操作系统虚拟化”</strong>（个中缘由，在本文评论区有相关讨论，这里就不细谈了）但是最近10多年来，“虚拟化”是大势所趋。所以 Intel 和 AMD 都在自家的芯片上提供了适合“虚拟化”的扩展机制。对 Intel 芯片而言，称之为“Intel-VT”（也叫“VT-x”）；对 AMD 芯片而言，称之为“AMD-V”。</p>

<p>　　请注意，VT 只在部分型号的芯片上提供。也就是说，不论是 Intel 还是 AMD，都只有某些型号的芯片是支持 VT 滴。 　　如果要从原理上阐述 VT 的用处，需要涉及到 x86 架构的设计及其缺陷，说来话长啊。考虑到篇幅，俺只举几个例子。 　　举例1：</p>

<p>　　有了 VT 之后，如果 Guest OS 中需要执行 CPU 的特权指令，虚拟机软件可以利用 VT 原生支持（硬件层面搞定）；如果没有 VT，碰到这种情况就只能靠软件模拟运行（<strong>靠软件模拟，效率会差很多！</strong>）。</p>

<p>　　很多同学抱怨电脑跑 VM 太慢，其中一部分人的原因就是——CPU【不】支持 VT。 　　举例2： 　　有了 VT 之后，你可以在“32位”的 Host OS 里面虚拟出“64位”的 Guest OS；若没有 VT 支持，就无法在“32位”上虚拟“64位”。 　　首先，你应该去查一下自己的电脑是啥型号的，然后 Google 一下该型号的硬件配置，通常都可以在那些电脑行情网站（比如：太平洋电脑网、中关村在线）上找到该型号使用的 CPU 规格。在 CPU 规格中，通常就会提到这款 CPU 是否支持 VT。万一在 CPU 规格中没有提及是否支持 VT，你可以根据该 CPU 的详细型号，再到 Intel 或 AMD 的官网上查，肯定能查到相关说明。 　　假如你查到自己的 CPU 是支持 VT 的，还没完。你还得到操作系统里面检验一下，看 VT 在操作系统层面是否可见。</p>

<p>　　<strong>对于使用 Windows 的同学</strong></p>

<p>　　Intel 和 AMD 各自都提供了专门的检测工具。不过俺还是推荐用微软提供的检测工具（Intel ＆ AMD 通吃）。下载链接在“<a href="https://www.microsoft.com/en-us/download/details.aspx?id=592">这里</a>”。该工具是绿色的（免安装），在 Host OS 中运行它，就会提示你的系统是否支持 VT。</p>

<p>　　<strong>对于使用 Linux 的同学</strong></p>

<p>　　请自行查看 Host OS 中的 <code>/proc/cpuinfo</code> 文件（命令如下） 对于 Intel 芯片，搜索 vmx 标志。</p>

<p>cat /proc/cpuinfo | grep vmx</p>

<p>对于 AMD 芯片，搜索 svm 标志。</p>

<p>cat /proc/cpuinfo | grep svm</p>

<p>　　如果你上网查到自己的 CPU 支持 VT，但用微软的检测工具却显示不支持，那么很可能是你【没有】在 BIOS 中开启 VT 设置。 　　如果你在 BIOS 中开启了 VT，但是微软的检测工具还是报告说“不支持 VT”，那么还有如下几种可能： 1. 有些电脑在系统启动时会锁定 VT 设置。所以你必须先【关机】，然后再开机并进入 BIOS 界面，再去修改 VT 设置。如果你只是【重启动系统】，没有进行【关机】操作，可能会导致 VT 的修改没生效。 2. 极少数便携式电脑在 BIOS 修改 VT 扩展之后，要进行【完全放电】，才能让修改生效。 3. 检查一下你的芯片驱动是否装对了<br />
　　所谓的“并行”（parallel），通俗而言就是：让 CPU 可以同时干多个事情。</p>

<p>　　CPU 的并行能力，主要通过三种技术来实现：多处理器（multi processor）、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%A0%B8%E5%BF%83%E8%99%95%E7%90%86%E5%99%A8">多核（multi core）</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92">超线程（hyper threading）</a>。</p>

<p>　　至于这三种的详细解释，俺就偷个懒，大伙儿自己去看维基百科吧。 　　这三种 CPU 的并行技术，其优缺点对比（尤其是前两种），网上有不少口水战。客观地讲，在不同的使用场景，不同技术的表现也是不同滴。所以很难一概而论地说哪个技术更好。 　　在“多 VM 同时运行”的场景下，俺个人认为： 其它指标相同的情况下，“N 个单核的 CPU”优于“一个 N 核的CPU” 其它指标相同的情况下，“一个双核的单线程 CPU”优于“一个单核的超线程 CPU”（注：“超线程”通常指“双线程”） 　　如果你正打算采购一台电脑，并且计划在该电脑上跑多个 VM。从“性价比”的角度考虑，你应该挑选“单 CPU 多核”。 　　因为个人用的电脑，主板大都只支持【单个 CPU】；支持多 CPU 的电脑，价格要高出很多。所以在性价比考虑之下，只能退而求其次，选“单 CPU 多核”——这是比较划算的方案。 　　至于应该买“几核”的 CPU，俺的建议是——在你的钞票预算内，核心数【多多益善】。 　　主流的虚拟机软件（VMware 和 VirtualBox）都可以指定 Guest OS 使用的 CPU 数量。 　　对于 VirtualBox，它提供的界面上让你设置的是“虚拟 CPU 数”（对应的是“核心数”）。你设置的数量要【小于等于】你物理 CPU 的“总核心数”（即使是超线程的 core 也只算1个）。</p>

<p>　　对于 VMware，它提供的界面上可以让你设置“CPU 数”与“每 CPU 核心数”。此处的设置比 VirtualBox 复杂。大伙儿可以参考 VMware 官网的文档（链接在“<a href="https://kb.vmware.com/s/article/1010184">这里</a>”）。</p>

<p>　　通常情况下，你只需设置为跟你的物理 CPU 的情况一致，就可以了。但是有些特殊情况，俺需要提醒一下。 　　VMware 下的特殊情况： 　　微软提供的某些 Windows 版本，会限制“可用 CPU 数”（这是微软的销售策略导致滴）。比如 Windows Server 2003 Standard Edition 限定了最多只能用4个 CPU（此处指【processor】，不是 core）；比如 WinXP 最多支持2个 CPU（也是指 processor）。如果你分配给 Guest OS 的 CPU（processor） 超过了该 Windows 的“CPU 上限”，那超出的部分就浪费啦。 　　相比 CPU，内存方面没有太多讲究。 　　如果你正在考虑买电脑，并且你想跑多个 VM，在预算范围内尽量买内存大的，或者是买来之后自己加内存。 　　需要多大的内存，取决于你需要【同时运行】的 VM 数量，以及每个 VM 的用途。 　　如果你善于优化，即使不大的内存，也可以同时跑好几个 VM（本文后续章节会稍微聊一下 Guest OS 的优化）。 　　目前所有的虚拟机软件，都可以让你单独设定每个 Guest OS 的内存大小。</p>

<p>　　<strong>给 Guest OS 配置内存，要恰到好处。</strong></p>

<p>　　如果配得太小，可能会导致 Guest OS 频繁使用虚拟内存，然后虚存频繁换页，就会导致频繁的磁盘 I/O，自然就拖慢【整台电脑】的性能。 　　如果配得太大，可能会导致留给 Host OS 的内存太小，然后 Host OS 频繁使用虚存，同样会出现频繁的内存换页和磁盘 I/O。【整台电脑】的性能同样会被拖慢。 　　如果电脑的物理内存【小于】4GB，你的 Host OS 可以装“32位”也可以装“64位”。俺通常建议想玩 VM 的同学装“64位”。因为装了“64位”之后，万一今后想扩展物理内存，就不存在 4GB 的限制。</p>

<p>　　如果电脑的物理内存【超过】4GB，你当然要直接上【64位】的操作系统。虽然从理论上讲，“32位”也可以玩转超过 4GB 的物理内存。不过捏，这需要通过一些旁门左道的技术（比如：<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95">PAE/物理地址扩展</a>）。俺个人不建议大伙儿（尤其是技术菜鸟）去折腾这种旁门左道。</p>

<p>　　“机械硬盘”大伙儿应该都比较熟悉了，俺就不介绍了。单说说新兴的“固态硬盘”（洋文缩写是 SSD）。 　　相比传统的硬盘，SSD 的【优点】很明显，至少有如下几个： 1. 读写速度飞快（尤其是读速度比机械硬盘快更多） 2. 无噪音 3. 无惧震动 4. 不发热 5. 低功耗 　　但是 SSD 的【缺点】同样明显，至少有如下几个： 1. 损坏后难恢复（相比机械硬盘，损坏前无预兆，一旦损坏就整块报废） 2. 写入次数很有限（这个可以通过“损耗均衡技术”来解决） 3. 价格 　　俺个人觉得：多数情况下，【没有必要】刻意追求 SSD。基于性价比考虑（如今 SSD 的价格还是偏高），花小钱升级内存比花大钱买 SSD 对性能的提升更明显。 　　因为普通人用电脑，操作的软件大都【不是】“磁盘 I/O 密集型”。比如你用浏览器上网，浏览器对磁盘的读写就非常非常少。比如你用 Office 处理文档，即使你设置了“每分钟自动保存”，对磁盘的读写依然是非常少的。 　　有些同学可能会问：自己天天下载电影，天天在电脑上播放，这样算不算“磁盘 I/O 密集型”？俺觉得这个都算不上。因为在线下载，瓶颈在网速（家用宽带也就 10Mbps 的数量级，SATA 的传输率是 Gbps 的数量级）。即使是播放本地高清视频文件，也远达不到磁盘传输的上限。 　　相对而言，如果你的内存足够大，就可以禁用操作系统的“虚拟内存”。如此一来就避免了虚存换页导致的“磁盘 I/O”——在内存紧张的情况下，虚存交换导致的磁盘读写，是很惊人的。（下面的章节还会再提到“虚拟内存”的优化）<br />
　　对于 PC 机而言，比较常见的硬盘接口有两种：一种是老式的 <a href="https://zh.wikipedia.org/wiki/ATA">PATA</a>（并行 ATA，也叫“IDE”），另一种是新式的 <a href="https://zh.wikipedia.org/wiki/SATA">SATA</a>（串行 ATA）。如今新买的电脑，估计都已经是 SATA 接口了。 　　因为电脑厂商要考虑旧操作系统的兼任性，所以大多数 PC 机的 BIOS 设置中，都保留了一个“IDE”的兼容模式。在新买的电脑中，有的电脑 BIOS 默认设置是 ACHI（用于 SATA），有的默认设置是 IDE。 　　如果你不确定的话，建议看一下你电脑的 BIOS 设置，看看硬盘的工作模式是哪个。如果依然是 IDE 模式，赶紧改成 ACHI 模式。因为 ACHI 模式才能完全发挥 SATA 接口的性能。 　　某些虚拟机软件同时支持多种虚拟磁盘格式（典型的就是 VirtualBox，支持好多种）。那么你在创建新的 Guest OS 时，应该选择哪种格式捏？俺的建议是：选择该虚拟机软件原生的格式。 　　以 VirtualBox 为例。 　　它同时支持 VDI、VMDK、VHD、HDD、QED 等多种格式。但是这些格式中，只有 VDI 是 VirtualBox【原生】支持滴——所谓的“原生支持”就是说，这个 VDI 格式本身就是 VirtualBox 的开发团队设计的。所以，对 VirtualBox 的用户而言，如无特殊情况，尽量用它原生的 VDI 磁盘格式。 　　下面是几款常见虚拟化软件【原生的】“虚拟磁盘格式”：</p>

<p>软件名称</p>

<p>原生磁盘格式</p>

<p>VirtualBox</p>

<p>VDI</p>

<p>各种 VMware</p>

<p>VMDK</p>

<p>Virtual PC<br />
Virtual Server</p>

<p>VHD</p>

<p>QEMU</p>

<p>QED</p>

<p>　　补充说明： 　　使用原生的磁盘格式，除了性能上的考虑，还有一个是基于“安全性”的考虑——对虚拟机用户而言，虚拟磁盘承载了你的数据，是非常重要滴。 　　由于原生的磁盘格式就是——虚拟化软件的开发团队自己设计的格式。所以对“原生格式”的支持，比较【不易】出故障和 Bug。 　　如果你的电脑只有【一块】物理硬盘，请跳过本小节。 　　如果你的电脑中同时插了多块物理硬盘，可以考虑用 RAID 来提升硬盘的读写性能。 　　由于大部分网友的电脑都是【单】硬盘，俺就不展开细聊了。有此需求的同学可以参考如下博文：</p>

<p>《<a href="https://program-think.blogspot.com/2020/06/Linux-Logical-Volume-Manager.html">扫盲 Linux 逻辑卷管理（LVM）——兼谈 RAID 以及“磁盘加密工具的整合”</a>》</p>

<p>　　如今很多网友都用上 Win7。但是 Win7 的内存占用是比较大滴。如果你想在 VM 里面跑 Win7，建议你改用 Windows ThinPC。这是微软官方发布的版本，根据 Win7 进行精简（含 Win7 SP1）。它的系统安装盘小了很多，安装后的硬盘占用也小了很多，启动后的内存占用也小了很多。关于 ThinPC 的更多介绍，可以看俺之前的博文《<a href="https://program-think.blogspot.com/2014/03/windows-xp-dead.html">Windows XP 大限已至——要不要换系统？如何换？</a>》。</p>

<p>　　如果你喜欢折腾技术，还可以用 Linux 作为 Guest OS。相比 Windows，Linux 的优点之一是：可以深度定制。通过定制，可以让它变得很轻量级，只占用很少的内存。如今已经有很多现成的“轻量级 Linux 发行版”（请看维基百科的<a href="https://en.wikipedia.org/wiki/Lightweight_Linux_distribution">这个链接</a>），其中一些只要几十兆内存就可以正常运行。</p>

<p>　　不熟悉 Linux 的同学可以参考俺之前的博文《<a href="https://program-think.blogspot.com/2013/10/linux-newbie-guide.html">扫盲 Linux：新手如何搞定 Linux 操作系统</a>》。<br />
　　比如说，如今网友们上网，经常会在浏览器中开启几十个标签页。当标签页开得很多时，浏览器占用的内存自然也猛增。但是不同的浏览器，差异还是很明显的。俺找到一篇今年（2014）的测评报告（<a href="https://www.ghacks.net/2014/01/02/chrome-34-firefox-29-internet-explorer-11-memory-use-2014/">英文原文</a>，<a href="http://www.iefans.net/ie11-chrome-34-firefox-29-neicun-zhanyong-ceshi/">中文翻译</a>），对比了 Chrome 34、Firefox 29、IE 11。当开启 40 个标签页的情况下，Firefox 的内存占用最小，IE 最大。并且 IE 占用内存几乎是 Firefox 的2倍。 　　俺举这个例子是想说明——选择性能更优秀的软件，会帮你节省很多内存。 　　Windows 是面向傻瓜用户的，而且 Windows 的应用范围很广（从商务办公到居家打游戏），所以它默认开启了很多系统服务。因为微软不确定这些服务是否会被用到，所以就把【可能用到】的服务，都设置为“自动”启动。 　　这样一来，确实方便了傻瓜用户，但是也导致默认的系统服务占用太多内存。所以你需要把那些你压根儿用不到的服务停掉（把启动方式修改为“手动”）。 　　（至于哪些服务可以停掉，大伙儿如果感兴趣，再另外写一篇） 　　很多软件（尤其是流氓软件）喜欢在“启动项”里面加东西。有些启动项压根儿用不到，岂不是白白浪费内存？ 　　所以你应该清理一下那些没啥用的启动项。 　　其实在刚才，俺已经提到了“虚拟内存”的话题。</p>

<p>　　“虚拟内存”简称“虚存”，洋文叫做“virtual memory”，维基百科的词条在“<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">这里</a>”。</p>

<p>　　经常听到有人抱怨系统太卡。当系统运行变慢的时候，你观察一下系统的内存使用，然后再看一下电脑的硬盘灯。如果系统的内存使用已经很高，并且硬盘灯长亮。这通常说明系统在进行频繁的“虚存交换/虚存换页”。这个过程需要进行频繁的磁盘读写，从而拖慢了整个系统。于是你就觉得系统很卡。 　　关于“虚存”，俺的经验是：先把物理内存搞大，然后禁用虚存。由于物理内存足够，并且虚存被禁用，那么就不存在“虚存交换”，这可以降低很多的磁盘 I/O 过程。 　　套用到 VM 管理上——你必须给每个 Guest OS 配置足够大的内存，然后在 Guest OS 里面禁用“虚存”（具体如何禁用，你自己去 Google 一下）。</p>

<p>　　<strong>注意事项：</strong></p>

<p>　　如果你要使用俺这个建议，要确保系统的内存是【足够大】滴！在禁用虚存的情况下，如果内存耗尽，可能会导致系统崩溃或者某个进程崩溃。 　　在本文的最后，俺顺便列举一些杂七杂八的注意事项。<br />
　　<strong>虽然这条放在“杂项”，但是这条很重要。</strong> 　　当你安装好 Guest OS 的操作系统之后，首先记得在这个 Guest OS 里面安装虚拟机软件的驱动。对于 VMware 而言，这玩意儿叫做“VMware Tools”；对 VirtualBox 而言，这玩意儿叫做“Guest Additions”。 　　装好之后，除了改善很多 GUI 方面的体验（比如“鼠标的无缝融合”，比如“改进 Guest 的屏幕分辨率”），还可以改善其它的一些虚拟设备的性能。 　　如果你要运行一些涉及 3D 的应用（比如 3D 游戏），要记得去 Guest OS 的设置界面，勾选“3D 加速”这个选项（VirtualBox 和 VMware 都有此选项）。 　　Guest OS 的虚拟磁盘文件，通常都很大很大（相当于把 Guest OS 的整个硬盘内容放在一个文件中）。如果 Host OS 里面的杀毒软件尝试去扫描这些虚拟磁盘文件，由于文件太大，会导致扫描过程消耗非常多的磁盘 I/O，从而拖慢你整台电脑的性能。 　　所以，你必须对杀毒软件进行一些设置，禁止它去扫描那些存放 Guest OS 的目录。</p>

<p><strong><a href="https://program-think.blogspot.com/2012/10/system-vm-0.html#index">回到本系列的目录</a></strong></p>

            </div>
            
        </div>
    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <br><br>
            <span>友链：<a href="http://www.xys.org/">新语丝</a>
                <span> </span><a href="https://twitter.com/fangshimin">方舟子Twitter</a>
            </span>
            <br><br>
            Copyright &copy; 编程随想镜像站 2021
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
</body>

</html>