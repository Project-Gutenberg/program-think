<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../post/index.xml">
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@SpeechFreedomCN">
    <meta name="twitter:creator" content="@SpeechFreedomCN">
    <meta name="og:title" content=" 软件工程进阶之每日构建[3]&amp;#65306;流程 | 编程随想镜像站 " />
    <meta name="og:description" content="在上一个帖子已经介绍了几方面的准备工作，今天来说一下具体流程。对于流程的每一个环节，俺会强调一下容易出问题的地方。 以下为了打字方便，把源代码管理系统简称为 RCS（Revision Control System）。 和老式的软件手工作坊不同，编程人员实现了某个功能点之后，不需要自己编译成二进制并提交给测试。取而代之的是，把代码提交到 RCS。凡是使用过RCS 的人，都应该知道如何提交代码，俺这里就不细说了。 这个步骤的注意点有两个：一个是保证提交的代码是能编译通过的；另一个是提交频度的问题。
　这两点在“善用工具”中有提及，这里再另外补充一点：有很多程序员在项目/工程中添加了文件之后，忘记在 RCS 里面也进行“添加操作”。虽然他/她本地的源代码都可以编译通过，但是在编译服务器上却编译失败。
　这个步骤是脚本【自动】进行的，不需要人为干预。 为了让脚本能够自己跑起来，你通常需要在操作系统里面设置一个“计划任务”来启动该脚本。 该脚本主要进行代码的 checkout/update（不同的 RCS 软件叫法不同）操作。由于各种 RCS 软件都会提供命令行方式。所以该脚本只需要调用命令行就可以搞定。 这个步骤比较简单，一般不会出什么问题。在该脚本执行完之后，就开始【自动执行】后续的编译脚本。 这个步骤的脚本比较复杂，得把所有需要编译的模块都编译过，然后再组装成安装包。 几乎所有编译型的编程语言，在其开发工具包中都自带有命令行的编译程序（比如 JDK 中的 javac、Visual C&#43;&#43; 中的 cl、Flex 中的 mxmlc &hellip;）。有了这些编译命令，再配合一些 make 工具（比如 Java 中的 Ant、VC 的 nmake、Posix上常用的 automake &hellip;），就可以把一个工程编译成若干二进制文件。 在所有的项目都编译通过后，下一步就可以制作安装包了。大部分安装包软件（比如InstallShield、NSIS、RPM等）也都提供命令行方式。制作完安装包之后，这个步骤也就大功告成了。 这个步骤比较容易出问题的一个地方在于编译某个工程可能失败。一旦发现失败，就只能终止整个编译过程。这时候最好能【自动】发出一个十万火急的邮件，告知每日构建的负责人及相关项目/产品的负责人。然后那个导致编译失败的家伙就有的好看了：轻则被臭骂一顿，重则被通报批评。 为什么编译失败怎么严重捏？因为每日构建号称是软件开发过程的心跳，自动编译一失败，就相当于心跳停了（下一个工作日，测试人员的工作都要受影响，项目进度也因此受影响），那当然很严重的啦。所以，一般来说，规模越大的团队，对导致编译失败的处罚越重。 另一个容易出问题的地方在于增量编译。所谓增量编译就是在 Make 某个工程时，只编译修改过的源代码文件（主要是对比源代码文件的修改时间和对应二进制文件的修改时间来判断）。有些工具在判断增量编译时不够智能，导致本该编译的源代码文件没有编译（很容易引发诡异问题）。所以为了保险起见，俺一般都使用全编译（也就是编译某个工程之前，把对应的二进制文件都删除）。 假设安装包被成功编译出来，下一个步骤就是把安装包【自动】传输到发布服务器上。这个负责传输的脚本也是放在编译服务器上，在编译脚本执行完之后再被调用。 这个步骤一般也不会出什么差错，除非你公司的网络不稳定，导致传输过程文件损坏（那你只能自认倒霉了）。" />
    <meta name="og:image"
        content="https://opvlbqxurl.execute-api.ap-northeast-2.amazonaws.com/prod/random?keyword=programming&slug=软件工程进阶之每日构建[3]&amp;#65306;流程" />
    <title> 软件工程进阶之每日构建[3]&amp;#65306;流程 | 编程随想镜像站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/css/blog.css" />
    
    <!-- plugins -->
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/bootstrap/bootstrap.min.css ">
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/themify-icons/themify-icons.css ">
    

</head>

<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/">Home</a>
        </div>
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/post/index.xml">RSS</a>
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(https://project-gutenberg.github.io/program-think/img/bg-blog.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                    软件工程进阶之每日构建[3]&amp;#65306;流程
                    
                </h1>
                
            </div>
        </div>
    </section>

<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-12">
        <div class="tile is-child box">
            

            <div class="content">
                <p>　　在<a href="https://program-think.blogspot.com/2009/02/daily-build-2-prepare.html">上一个帖子</a>已经介绍了几方面的准备工作，今天来说一下具体流程。对于流程的每一个环节，俺会强调一下容易出问题的地方。 　　以下为了打字方便，把源代码管理系统简称为 RCS（Revision Control System）。 　　和老式的软件手工作坊不同，编程人员实现了某个功能点之后，不需要自己编译成二进制并提交给测试。取而代之的是，把代码提交到 RCS。凡是使用过RCS 的人，都应该知道如何提交代码，俺这里就不细说了。 　　这个步骤的注意点有两个：一个是保证提交的代码是能编译通过的；另一个是提交频度的问题。</p>

<p>　　这两点在“<a href="https://program-think.blogspot.com/2009/02/6.html#rcs">善用工具</a>”中有提及，这里再另外补充一点：有很多程序员在项目/工程中添加了文件之后，忘记在 RCS 里面也进行“添加操作”。虽然他/她本地的源代码都可以编译通过，但是在编译服务器上却编译失败。</p>

<p>　　这个步骤是脚本【自动】进行的，不需要人为干预。 　　为了让脚本能够自己跑起来，你通常需要在操作系统里面设置一个“计划任务”来启动该脚本。 　　该脚本主要进行代码的 checkout/update（不同的 RCS 软件叫法不同）操作。由于各种 RCS 软件都会提供命令行方式。所以该脚本只需要调用命令行就可以搞定。 　　这个步骤比较简单，一般不会出什么问题。在该脚本执行完之后，就开始【自动执行】后续的编译脚本。 　　这个步骤的脚本比较复杂，得把所有需要编译的模块都编译过，然后再组装成安装包。 　　几乎所有编译型的编程语言，在其开发工具包中都自带有命令行的编译程序（比如 JDK 中的 javac、Visual C++ 中的 cl、Flex 中的 mxmlc &hellip;）。有了这些编译命令，再配合一些 make 工具（比如 Java 中的 Ant、VC 的 nmake、Posix上常用的 automake &hellip;），就可以把一个工程编译成若干二进制文件。 　　在所有的项目都编译通过后，下一步就可以制作安装包了。大部分安装包软件（比如InstallShield、NSIS、RPM等）也都提供命令行方式。制作完安装包之后，这个步骤也就大功告成了。 　　这个步骤比较容易出问题的一个地方在于编译某个工程可能失败。一旦发现失败，就只能终止整个编译过程。这时候最好能【自动】发出一个十万火急的邮件，告知每日构建的负责人及相关项目/产品的负责人。然后那个导致编译失败的家伙就有的好看了：轻则被臭骂一顿，重则被通报批评。 　　为什么编译失败怎么严重捏？因为每日构建号称是软件开发过程的心跳，自动编译一失败，就相当于心跳停了（下一个工作日，测试人员的工作都要受影响，项目进度也因此受影响），那当然很严重的啦。所以，一般来说，规模越大的团队，对导致编译失败的处罚越重。 　　另一个容易出问题的地方在于增量编译。所谓增量编译就是在 Make 某个工程时，只编译修改过的源代码文件（主要是对比源代码文件的修改时间和对应二进制文件的修改时间来判断）。有些工具在判断增量编译时不够智能，导致本该编译的源代码文件没有编译（很容易引发诡异问题）。所以为了保险起见，俺一般都使用全编译（也就是编译某个工程之前，把对应的二进制文件都删除）。 　　假设安装包被成功编译出来，下一个步骤就是把安装包【自动】传输到发布服务器上。这个负责传输的脚本也是放在编译服务器上，在编译脚本执行完之后再被调用。 　　这个步骤一般也不会出什么差错，除非你公司的网络不稳定，导致传输过程文件损坏（那你只能自认倒霉了）。<br />
　　如果你从来没听说过“冒烟测试”，请看“<a href="https://en.wikipedia.org/wiki/Smoke_testing">这里</a>”的介绍。 　　先说明一下，冒烟测试并【不是必做】的步骤，不过俺建议还是做一下比较好。冒烟测试是对软件最主要的功能进行一些简单基本的验证，保证自动编译出来的安装包是【基本可用】滴。如果冒烟测试不通过（和编译失败类似，也算是严重事故），则表明软件本身有严重 Bug，测试人员也就不用再费劲测试这个版本了（免得瞎忙乎）。 　　“冒烟测试”一般由某个专门的冒烟测试脚本负责。这个脚本一般放在测试服务器上，也是通过诸如计划任务来定时启动，然后从发布服务器上取下安装包，并进行相关的验证。 　　如果上述几个环节都还顺利，那么，下一个工作日上班的时候，测试人员就可以从发布服务器获取到安装包，并开始进行一天的测试工作了。 　　这里有一个小建议：“测试人员下载安装包并进行安装”最好也是通过脚本【自动】来做。这样的话，当测试人员上班的时候，当天凌晨做好的安装包就已经【自动】安装在测试机器上了，测试人员一打开电脑，就可以开始测试软件了。这不是很爽吗？</p>

<p>　　上述就是每日构建的几个主要步骤，<a href="https://program-think.blogspot.com/2009/06/daily-build-4-tools.html">下一个帖子</a>聊一下与每日构建相关的工具。</p>

            </div>
            
        </div>
    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <br><br>
            <span>友链：<a href="http://www.xys.org/">新语丝</a>
                <span> </span><a href="https://twitter.com/fangshimin">方舟子Twitter</a>
            </span>
            <br><br>
            Copyright &copy; 编程随想镜像站 2021
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
</body>

</html>