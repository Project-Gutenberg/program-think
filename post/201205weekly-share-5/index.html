<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../post/index.xml">
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@SpeechFreedomCN">
    <meta name="twitter:creator" content="@SpeechFreedomCN">
    <meta name="og:title" content=" 每周转载&amp;#65306;IT 大牛谈编程语言&amp;#65288;网文3篇&amp;#65289; | 编程随想镜像站 " />
    <meta name="og:description" content="最近老是在写政治类话题。为了照顾一下俺博客的程序员读者，本周分享3篇关于编程语言的短文（皆出自名家之手）。
　作者 Paul Graham 不但是硅谷的【技术大牛】，还是硅谷的【创业教父】。对许多问题（软件开发、企业管理、创业、艺术&hellip;），他都有独到见解。
他的代表作是《黑客与画家》（俺的网盘上有电子版）。本文就出自此书，洋文标题是：《Being Popular》。文中描绘了作者心目中理想的编程语言，供大伙儿参考。虽然这篇是2001年发表，距今超过10年。但是，好的文章是不会随时间流逝而贬值滴。 提醒一下： 文中提及的“黑客”，是【褒义】滴！大伙儿不要把 hacker 与 cracker 混为一谈。
 　我的朋友曾对一位著名的操作系统专家说他想要设计一种真正优秀的编程语言。那位专家回答，这是浪费时间，优秀的语言不一定会被市场接受，很可能无人使用，因为语言的流行不取决于它本身。至少，那位专家设计的语言就遭遇到了这种情况。 那么，语言的流行到底取决于什么因素呢？流行的语言是否真的值得流行呢？还有必要尝试设计一种更好的语言吗？如果有必要的话，怎样才能做到这一点呢？ 为了找到这些问题的答案，我想我们可以观察黑客，了解他们使用什么语言。编程语言本来就是为了满足黑客的需要而产生的，当且仅当黑客喜欢一种语言时，这种语言才能成为合格的编程语言，而不是被当做“指称语义”（denotational semantics）或者编译器设计。
　流行的秘诀
　没错，大多数人选择某一种编程语言，不是因为这种语言有什么独特的特点，而是因为听说其他人使用这种语言。但是我认为，外界因素对于编程语言的流行其实并没有想象中那么大的影响力。我倒是觉得，问题出在对于什么是优秀编程语言，黑客的看法与大多数的语言设计者不一样。 黑客的看法其实比语言设计者的更重要。编程语言不是数学定理，而是一种工具，为了便于使用，它们才被设计出来。所以，设计编程语言的时候必须考虑到人类的长处和短处，就像设计鞋子的时候必须符合人类的脚型。如果鞋子穿上去不舒服，无论它的外形多么优美，多么像一件艺术品，你也只能把它当做一双坏鞋。 大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有的优秀软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。 专家级黑客的看法不是决定一种语言流行程度的唯一因素，某些古老的软件（Fortran 和 Cobol 的情况）和铺天盖地的广告宣传（Ada 和 Java 的情况）也会起到作用。但是，我认为从长期来看，专家级黑客的看法是最重要的因素。只要有了达到“临界数量”（critical mass）的最初用户和足够长的时间，一种语言就可能会达到应有的流行程度。而流行本身又会使得这种优秀的语言更加优秀，进一步拉大它与平庸语言之间的好坏差异，因为使用者的反馈总是会导致语言的改进。你可以想一下，所有流行的编程语言从诞生至今的变化有多大。Perl 和 Fortran 是极端的例子，但是甚至就连Lisp都发生了很大的变化。 所以，即使不考虑语言本身的优秀是否能带动流行，我想单单流行本身就肯定会使得这种语言变得更好，只有流行才会让它保持优秀。编程语言的最高境界一直在发展之中。虽然语言的核心功能就像大海的深处，很少有变化，但是函数库和开发环境之类的东西就像大海的表面，一直在汹涌澎湃。 当然，黑客必须先知道这种语言，才可能去用它。他们怎么才能知道呢？就是从其他黑客那里。所以不管怎样，一开始必须有一群黑客使用这种语言，然后其他人才会知道它。我不知道“一群”的最小数量是多少，多少个黑客才算达到“临界数量”呢？如果让我猜，我会说20人。如果一种语言有20个独立用户，就意味着有20个人是自主决定使用这种语言的，我觉得这就说明这种语言真的有优点。 达到这一步并非易事。如果说用户数从0到20比从20到1000更困难，我也不会感到惊讶。发展最早的20个用户的最好方法可能就是使用特洛伊木马：你让人们使用一种他们需要的应用程序，这个程序碰巧就是用某种新语言开发的。
　外部因素
　我们得先承认，确实有一个外部因素会影响到语言的流行。一种语言必须是某一个流行的计算机系统的脚本语言（scripting language），才会变得流行。Fortran 和 Cobol 是早期 IBM 大型机的脚本语言。C 是 Unix 的脚本语言，后来的 Perl 和 Python 也是如此。Tcl 是 Tk 的脚本语言，Visual Basic 是 Windows 的脚本语言,（某种形式的）Lisp 是 Emacs 的脚本语言，PHP 是网络服务器的脚本语言，Java 和 JavaScript 是浏览器的脚本语言。 编程语言不是存在于真空之中。“编程”其实是及物动词，黑客一般都是为某个系统编程，在现实中，编程语言总是与它们依附的系统联系在一起的。所以，如果你想设计一种流行的编程语言，就不能只是单纯地设计语言本身，还必须为它找到一个依附的系统，而这个系统也必须流行。除非你只想用自己设计的语言取代那个系统现有的脚本语言。 这种情况导致的一个结果就是，无法以一种语言本身的优缺点评判这种语言。另一个结果则是，只有当一种语言是某个系统的脚本语言时，它才能真正成为编程语言。如果你对此很吃惊，觉得不公平，那么我会跟你说不必大惊小怪。这就好比大家都认为，如果一种编程语言只有语法规则，没有一个好的实现（implementation），那么它就不能算完整的编程语言。这些都是很正常很合理的事情，编程语言本来就该如此。 当然，编程语言本来就需要一个好的实现，而且这个实现必须是免费的。商业公司愿意出钱购买软件，但是黑客作为个人不会愿意这样做，而你想让一种语言成功，恰恰就是需要吸引黑客。 编程语言还需要有一本介绍它的书。这本书应该不厚，文笔流畅，而且包含大量优秀的范例。布赖恩·柯尼汉和丹尼斯·里奇合写的《C 程序设计语言》（C Programming Language）就是这方面的典范。眼下，我大概还能再加一句，这一类书籍之中必须有一本由 O&rsquo;Reilly 公司出版发行。这正在变成是否能吸引黑客的前提条件了。 编程语言还应该有在线文档。事实上，在线文档可以当做一本书来写，但是目前它还无法取代实体书。实体书并没有过时，它们读起来很方便，而且出版社对书籍内容的审核是一种很有用的质量保证机制（虽然做得很不完美）。书店则是程序员发现和学习新语言的最重要的场所之一。" />
    <meta name="og:image"
        content="https://opvlbqxurl.execute-api.ap-northeast-2.amazonaws.com/prod/random?keyword=programming&slug=每周转载&amp;#65306;IT 大牛谈编程语言&amp;#65288;网文3篇&amp;#65289;" />
    <title> 每周转载&amp;#65306;IT 大牛谈编程语言&amp;#65288;网文3篇&amp;#65289; | 编程随想镜像站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151212685-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" />
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/css/blog.css" />
    
    <!-- plugins -->
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/bootstrap/bootstrap.min.css ">
    
    <link rel="stylesheet" href="https://project-gutenberg.github.io/program-think/plugins/themify-icons/themify-icons.css ">
    

</head>

<body>

    
    <nav class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/">Home</a>
        </div>
        <div class="navbar-brand">
            <a class="navbar-item" href="https://project-gutenberg.github.io/program-think/post/index.xml">RSS</a>
        </div>
    </nav>
    

    
    <section class="hero is-info is-medium">
        <div class="hero-body" style="background-image: url(https://project-gutenberg.github.io/program-think/img/bg-blog.jpg);">
            <div class="container has-text-centered">
                <br>
                <h1 class="title is-size-1">
                    
                    每周转载&amp;#65306;IT 大牛谈编程语言&amp;#65288;网文3篇&amp;#65289;
                    
                </h1>
                
            </div>
        </div>
    </section>

<div class="container">
    <div class="section">
    

<div class="columns">
    <div class="column is-12">
        <div class="tile is-child box">
            

            <div class="content">
                <p>　　最近老是在写政治类话题。为了照顾一下俺博客的程序员读者，本周分享3篇关于编程语言的短文（皆出自名家之手）。</p>

<p>　　作者 <a href="https://en.wikipedia.org/wiki/Paul_Graham_%28computer_programmer%29">Paul Graham</a> 不但是硅谷的【技术大牛】，还是硅谷的【创业教父】。对许多问题（软件开发、企业管理、创业、艺术&hellip;），他都有独到见解。<br />
　　他的代表作是《<a href="https://docs.google.com/document/d/17i49-SpeKz1wRG5S-HPonO-lXJHD99h62gDsQ64NWXo/">黑客与画家</a>》（<a href="https://github.com/programthink/books">俺的网盘</a>上有电子版）。本文就出自此书，洋文标题是：《Being Popular》。文中描绘了作者心目中理想的编程语言，供大伙儿参考。虽然这篇是2001年发表，距今超过10年。但是，好的文章是不会随时间流逝而贬值滴。 　　提醒一下： 　　文中提及的“黑客”，是【褒义】滴！大伙儿不要把 hacker 与 cracker 混为一谈。</p>

<blockquote>
<p>　　我的朋友曾对一位著名的操作系统专家说他想要设计一种真正优秀的编程语言。那位专家回答，这是浪费时间，优秀的语言不一定会被市场接受，很可能无人使用，因为语言的流行不取决于它本身。至少，那位专家设计的语言就遭遇到了这种情况。 　　那么，语言的流行到底取决于什么因素呢？流行的语言是否真的值得流行呢？还有必要尝试设计一种更好的语言吗？如果有必要的话，怎样才能做到这一点呢？ 　　为了找到这些问题的答案，我想我们可以观察黑客，了解他们使用什么语言。编程语言本来就是为了满足黑客的需要而产生的，当且仅当黑客喜欢一种语言时，这种语言才能成为合格的编程语言，而不是被当做“指称语义”（denotational semantics）或者编译器设计。</p>

<p>　　<strong>流行的秘诀</strong></p>

<p>　　没错，大多数人选择某一种编程语言，不是因为这种语言有什么独特的特点，而是因为听说其他人使用这种语言。但是我认为，外界因素对于编程语言的流行其实并没有想象中那么大的影响力。我倒是觉得，问题出在对于什么是优秀编程语言，黑客的看法与大多数的语言设计者不一样。 　　黑客的看法其实比语言设计者的更重要。编程语言不是数学定理，而是一种工具，为了便于使用，它们才被设计出来。所以，设计编程语言的时候必须考虑到人类的长处和短处，就像设计鞋子的时候必须符合人类的脚型。如果鞋子穿上去不舒服，无论它的外形多么优美，多么像一件艺术品，你也只能把它当做一双坏鞋。 　　大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有的优秀软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。 　　专家级黑客的看法不是决定一种语言流行程度的唯一因素，某些古老的软件（Fortran 和 Cobol 的情况）和铺天盖地的广告宣传（Ada 和 Java 的情况）也会起到作用。但是，我认为从长期来看，专家级黑客的看法是最重要的因素。只要有了达到“临界数量”（critical mass）的最初用户和足够长的时间，一种语言就可能会达到应有的流行程度。而流行本身又会使得这种优秀的语言更加优秀，进一步拉大它与平庸语言之间的好坏差异，因为使用者的反馈总是会导致语言的改进。你可以想一下，所有流行的编程语言从诞生至今的变化有多大。Perl 和 Fortran 是极端的例子，但是甚至就连Lisp都发生了很大的变化。 　　所以，即使不考虑语言本身的优秀是否能带动流行，我想单单流行本身就肯定会使得这种语言变得更好，只有流行才会让它保持优秀。编程语言的最高境界一直在发展之中。虽然语言的核心功能就像大海的深处，很少有变化，但是函数库和开发环境之类的东西就像大海的表面，一直在汹涌澎湃。 　　当然，黑客必须先知道这种语言，才可能去用它。他们怎么才能知道呢？就是从其他黑客那里。所以不管怎样，一开始必须有一群黑客使用这种语言，然后其他人才会知道它。我不知道“一群”的最小数量是多少，多少个黑客才算达到“临界数量”呢？如果让我猜，我会说20人。如果一种语言有20个独立用户，就意味着有20个人是自主决定使用这种语言的，我觉得这就说明这种语言真的有优点。 　　达到这一步并非易事。如果说用户数从0到20比从20到1000更困难，我也不会感到惊讶。发展最早的20个用户的最好方法可能就是使用特洛伊木马：你让人们使用一种他们需要的应用程序，这个程序碰巧就是用某种新语言开发的。</p>

<p>　　<strong>外部因素</strong></p>

<p>　　我们得先承认，确实有一个外部因素会影响到语言的流行。一种语言必须是某一个流行的计算机系统的脚本语言（scripting language），才会变得流行。Fortran 和 Cobol 是早期 IBM 大型机的脚本语言。C 是 Unix 的脚本语言，后来的 Perl 和 Python 也是如此。Tcl 是 Tk 的脚本语言，Visual Basic 是 Windows 的脚本语言,（某种形式的）Lisp 是 Emacs 的脚本语言，PHP 是网络服务器的脚本语言，Java 和 JavaScript 是浏览器的脚本语言。 　　编程语言不是存在于真空之中。“编程”其实是及物动词，黑客一般都是为某个系统编程，在现实中，编程语言总是与它们依附的系统联系在一起的。所以，如果你想设计一种流行的编程语言，就不能只是单纯地设计语言本身，还必须为它找到一个依附的系统，而这个系统也必须流行。除非你只想用自己设计的语言取代那个系统现有的脚本语言。 　　这种情况导致的一个结果就是，无法以一种语言本身的优缺点评判这种语言。另一个结果则是，只有当一种语言是某个系统的脚本语言时，它才能真正成为编程语言。如果你对此很吃惊，觉得不公平，那么我会跟你说不必大惊小怪。这就好比大家都认为，如果一种编程语言只有语法规则，没有一个好的实现（implementation），那么它就不能算完整的编程语言。这些都是很正常很合理的事情，编程语言本来就该如此。 　　当然，编程语言本来就需要一个好的实现，而且这个实现必须是免费的。商业公司愿意出钱购买软件，但是黑客作为个人不会愿意这样做，而你想让一种语言成功，恰恰就是需要吸引黑客。 　　编程语言还需要有一本介绍它的书。这本书应该不厚，文笔流畅，而且包含大量优秀的范例。布赖恩·柯尼汉和丹尼斯·里奇合写的《C 程序设计语言》（C Programming Language）就是这方面的典范。眼下，我大概还能再加一句，这一类书籍之中必须有一本由 O&rsquo;Reilly 公司出版发行。这正在变成是否能吸引黑客的前提条件了。 　　编程语言还应该有在线文档。事实上，在线文档可以当做一本书来写，但是目前它还无法取代实体书。实体书并没有过时，它们读起来很方便，而且出版社对书籍内容的审核是一种很有用的质量保证机制（虽然做得很不完美）。书店则是程序员发现和学习新语言的最重要的场所之一。</p>

<p>　　<strong>简洁</strong></p>

<p>　　假定你的语言已经能够满足上面三项条件——一种免费的实现，一本相关书籍，以及语言所依附的计算机系统——那么还需要做什么才能使得黑客喜欢上你的语言？ 　　黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。有一个笑话说，黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。这个笑话其实与真实情况相差无几。就算这真的是个笑话，语言的设计者也必须把它当真，按照它的要求设计语言。 　　简洁性最重要的方面就是要使得语言更抽象。为了达到这一点，首先你设计的必须是高级语言，然后把它设计得越抽象越好。语言设计者应该总是看着代码，问自己能不能使用更少的语法单位把它表达出来。如果你有办法让许多不同的程序都能更简短地表达出来，那么这很可能意味着你发现了一种很有用的新抽象方法。 　　不要觉得为用户着想就是让他们使用像英语一样又长又啰唆的语法。这是不正确的做法，Cobol 就是因为这个毛病而声名狼藉。 　　如果你让黑客像下面这样求和：</p>

<p><code>add x to y giving z</code></p>

<p>　　而不是写成：</p>

<p><code>z = x + y</code></p>

<p>　　那么你就是在侮辱黑客的智商，或者自己作孽了。 　　简洁性是静态类型语言的力所不及之处。不考虑其他因素时，没人愿意在程序的头部写上一大堆的声明语句。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。举例来说，“hello world”本应该是一个很简单的程序，但是在 Java 语言中却要写上一大堆东西，这本身就差不多可以说明 Java 语言设计得有问题了。 　　单个的语法单位也应该很简短。Perl 和 Common Lisp 在这方面是两个不同的极端。Perl 的语法单位很短，导致它的代码可以拥挤得让人无法理解，而 Common Lisp 内置运算符的名称则长得可笑。Common Lisp 的设计者们可能觉得文本编辑器会帮助用户自动填写运算符的长名称。但是这样做的代价不仅是增加了打字的工作量，还包括提高了阅读代码的难度，以及占用了更多的显示器空间。</p>

<p>　　<strong>可编程性（Hackability）</strong></p>

<p>　　对黑客来说，选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。在编程语言的历史上，防止程序员做出“错误”举动的措施多得惊人。这是语言设计者很自以为是的危险举动，他们怎么知道程序员该做什么不该做什么？我认为，语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。你也许能够阻止他引用另一个模块中的变量，但是你没法防止他日日夜夜不知疲倦地写出结构混乱的程序去解决完全错误的问题。 　　优秀程序员经常想做一些既危险又令人恼火的事情。所谓“令人恼火”，我指的是他们会突破设计者提供给用户的外部语义层，试着控制某些高级抽象的语言内部接口。比如，黑客喜欢破解，而破解就意味着深入内部，揣测原始设计者的意图。 　　你应该敞开胸怀，欢迎这种揣测。对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。如果你制造的是编程语言这样高度组合的系统，那就更是如此了。许多黑客会用你做梦也想不到的方式改动你的语法模型。我的建议就是，让他们这样干吧，而且应该为他们创造便利，尽可能多地把语言的内部暴露在他们面前。 　　其实，黑客并不会彻底颠覆你的工具，在一个大型程序中，他可能只是对语言改造一两个地方。但是，改动多少地方并不重要，重要的是他能够对语言进行改动。这可能不仅有助于解决一些特殊的问题，还会让黑客觉得很好玩。黑客改造语言的乐趣就好比外科医生摆弄病人内脏的乐趣，或者青少年喜欢用手挤破青春痘的那种感觉。至少对男生来说，某些类型的破坏非常刺激。针对青年男性读者的 Maxim 杂志每年出版一本特辑，里面一半是美女照片，另一半是各种严重事故的现场照片。这本杂志非常清楚它的读者想看什么。 　　一种真正优秀的编程语言应该既整洁又混乱。“整洁”的意思是设计得很清楚， 内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。“混乱”的意思是它允许黑客以自己的方式使用。C 语言就是这样的例子，早期的 Lisp 语言也是如此。真正的黑客语言总是稍微带一点放纵不羁、不服管教的个性。 　　优秀的编程语言所具备的功能，应该会使得言必称“软件工程”的人感到非常不满、频频摇头。与黑客语言形成鲜明对照的就是像 Pascal 那样的语言，它是井然有序的模范，非常适合教学，但是除此之外就没有很大用处了。</p>

<p>　　<strong>一次性程序</strong></p>

<p>　　为了吸引黑客，一种编程语言必须善于完成黑客想要完成的各种任务。这意味着它必须很适合开发一次性程序。这一点可能出乎很多人的意料。 　　所谓一次性程序，就是指为了完成某些很简单的临时性任务而在很短时间内写出来的程序。比如，自动完成某些系统管理任务的程序，或者（为了某项模拟任务）自动生成测试数据的程序，以及在不同格式之间转化数据的程序等。令人吃惊的是，一次性程序往往不是真的只用一次，就像二战期间很多美国大学造的一大批临时建筑后来都成了永久建筑。许多一次性程序后来也都变成了正式的程序，具备了正式的功能和外部用户。 　　我有一种预感，最优秀的那些大型程序就是这样发展起来的，而不是像胡佛水坝那样从一开始就作为大型工程来设计。一下子从无到有做出一个大项目是一件很恐怖的事。当人们接手一个巨型项目时，很容易被它搞得一蹶不振。最后，要么是项目陷入僵局，要么是做出来一个规模小、性能差的东西。你想造一片闹市，却只做出一家商场；你想建一个罗马，却只造出一个巴西利亚；你想发明 C 语言，却只开发出 Ada。 　　开发大型程序的另一个方法就是从一次性程序开始，然后不断地改进。这种方法比较不会让人望而生畏，程序在不断的开发之中逐渐进步。一般来说，使用这种方法开发程序，一开始用什么编程语言，就会一直用到最后，因为除非有外部政治因素的干预，程序员很少会中途更换编程语言。所以，我们就有了一个看似矛盾的结论：如果你想设计一种适合开发大型项目的编程语言，就必须使得这种语言也适合开发一次性程序，因为大型项目就是从一次性程序演变而来的。 　　Perl 就是一个鲜明的例子。它不仅仅设计成适合开发一次性程序，而且它本身就很像一次性程序。最初的 Perl 只是好几个生成表格的工具收集在一起而已。后来程序员用它写一次性程序，当那些程序逐渐发展壮大后，Perl 才随之发展成了一种正式的编程语言。到了 Perl 5，这种语言才适合开发重要的程序，但是在此之前它已经广为流行了。 　　什么样的语言适合写一次性程序？首先，它必须很容易装备。一次性程序是你只想在一小时内写出来的程序，所以它不应该耗费很多时间安装和配置，最好已经安装在你的电脑上了。它必须是想用就用的。C 语言可以想用就用，因为它是操作系统的一部分；Perl 可以想用就用，因为它本来就是一种系统管理工具，操作系统已经默认安装它了。 　　很容易装备不仅仅指很容易安装或者已经安装，还指很容易与使用者互动。一种有命令行界面、可以实时反馈的语言就具有互动性，那些必须先编译后使用的语言就不具备互动性。受欢迎的编程语言应该是前者，具有良好的互动性，可以快速得到运行结果。</p>

<p>　　一次性程序的另一个特点就是简洁。对黑客来说，这一点永远有吸引力。如果考虑到你最多只打算在这个程序上耗费一个小时，这一点就更重要了。</p>
</blockquote>

<p>　　作者 <a href="https://en.wikipedia.org/wiki/Bruce_Eckel">Bruce Eckel</a> 是编程界的大牛，著有大名鼎鼎的《<a href="https://docs.google.com/document/d/1HOhVvDd2So2L-KUBBjF_VOAHbg5RfiWh2laDpuVWRps/">Thinking in C++</a>》和《<a href="https://docs.google.com/document/d/1xlRZr4YgCLKSzka42kBXXkytHGmjIE5CF69GDJNN9O0/">Thinking in Java</a>》（<a href="https://github.com/programthink/books">俺的网盘</a>上分享了这两本书的电子版） 　　本文是他对程序员（尤其是【新手】）的忠告，写于2009年，英文标题是：《A Career in Computing》。</p>

<blockquote>
<p>　　大家总是问一个错误的问题：“我应该学习 C++ 还是 Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。 　　请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell 脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。 　　问我这样的问题的人可能来自其他行业，或者来自诸如 Web 开发之类的领域。他们知道 HTML 是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>

<p>　　<strong>在这个领域做得越多，我越觉得：<a href="https://www.artima.com/weblogs/viewpost.jsp?thread=255898">软件开发比任何行业都更接近于写作</a>。</strong>我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如“测不准原理”对人类的影响。（编程随想注：译文中的这个“测不准原理”不妥，应该翻译为“不确定性原理”，具体原因参见“<a href="https://program-think.blogspot.com/2015/03/Translation-Mistakes.html">这篇博文</a>”）</p>

<p>　　我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。 　　我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。 　　当互联网刚刚兴起时，仅仅是花一点时间学习 HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML 程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>

<p>　　我想说的是：<strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>

<p>　　当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会&hellip;&hellip;<strong>你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</strong></p>

<p>　　另一个方法是：先大致了解这个领域，找到最适合你的地方。打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。 　　我在高校里待了很久，甚至还在 UCLA（注：加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。 　　但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。</p>

<p>　　<strong>了解编程之外的领域，将会极大得提高你解决问题的能力（就如同多学几种编程语言将极大地提高你的编程技能）。</strong>很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>

<p>　　有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征： ◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。 ◇知道如何获取知识 ◇Study prior art ◇善用工具 ◇学会把事情简化 ◇理解业务 ◇为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。 ◇成为一个领导者，善于沟通和激励。 ◇搞清楚你在为谁服务 ◇没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。 ◇明白完美是渐进的 　　适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>

<p>　　或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++ 还是 Java？”<strong>我再重复一次：并不是所有的问题都有一个唯一的简单的答案。问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。</strong>相信我所说的，你的生活会更精彩！</p>
</blockquote>

<p>　　作者 <a href="https://en.wikipedia.org/wiki/Peter_Norvig">Peter Norvig</a> 是计算机科学家，Google 的研究总监。他在“人工智能领域”很有名气。<a href="https://github.com/programthink/books">俺的网盘</a>上分享了他写的《<a href="https://docs.google.com/document/d/10AF_r1EtIImjTUh4Pz80mFaGTDcOs72rN7vPwMPYoTk/">人工智能——一种现代的方法</a>》 　　此文的原标题是：《Teach Yourself Programming in Ten Years》。作者会告诉你：为什么急功近利地学习软件开发技术是没效果滴？</p>

<blockquote>
<p>　　<strong>为啥都想速成？</strong> 　　随便逛一下书店，你会看到《7天自学 Java》等诸如此类的 N 天甚至 N 小时学习 Visual Basic、Windows、Internet 的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96% 是计算机的书。</p>

<p>　　结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“_坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。_”</p>

<p>　　让我们看看《三日学会 C++》这个书名意味着什么： 　　“学习”</p>

<p>　　三天内你可能没有时间写出有意义的程序，或者从中积累经验。你不可能有时间去跟职业编程者一起去理解在 C++ 环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：“_一知半解是很危险的_”。</p>

<p>　　“C++”</p>

<p>　　三天内你可能学会 C++ 的句法（如果你已经了解其他的语言），但你还不会使用它。打个比方，假如你是个 Basic 程序员，你可能写出 Basic 风格的 C++ 程序，而无法理解 C++ 的真实好处。那要点是什么？艾伦·佩里斯（Alan Perlis）曾经说过：“_一门不能影响你编程观点的语言不值得去学。_”有可能你学了一点点 C++（或者诸如 Javascript、Flex 之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。</p>

<p>　　“三日” 　　不幸地是，这远远不够，下一部分会详细讲。</p>

<p>　　<strong>如何用十年掌握编程？</strong></p>

<p>　　研究人员（Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)）得出结论：想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。<strong>关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能力限度的事情，尝试并思考你的表现，并自我矫正。周而复始。</strong>这并无捷径！4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。</p>

<p>　　马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况： 所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。</p>

<p>　　所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson，1709~1784）认为还需更长时间：“_卓越乃一生之追求，而非其它_”。乔叟（Chaucer，1340~1400）抱怨道：“_the lyf so short, the craft so long to lerne._”（生之有限，学也无涯）。希波克拉底（Hippocrates，400BC）因这句话被世人所知：“_ars longa, vita brevis_”（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是：“_Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile_”，翻译成英文就是：“_Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult._”（生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。</p>

<p>　　<strong>我的编程成功秘笈是：</strong></p>

<p>◇首先要对编程感兴趣，能从编程中得到乐趣。 一定要让它足够有趣，因为你要保持你的兴趣长达十年。 ◇与别的程序员交流。 阅读别人的代码——这比看任何书或参加培训课都重要。 ◇实践。</p>

<p>最好的学习乃实践。俗话说：“_编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。_” (p. 366) “最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。” (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。</p>

<p>◇如果你愿意，花四年学习大学课程（或者再加上读研）。 这将给你赢得某些工作机会，并给予你在该领域的深层见解。但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker&rsquo;s Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。 ◇和其他程序员一起参与工程项目。 在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。 ◇继续别人的工程项目。 去理解先前程序员写的程序。学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。 ◇至少学6种程序语言。 其中包括一种支持类抽象的（Java 和 C++），一种支持函数抽象的（如 Lisp 或 ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如 Prolog 或 C++ 模板），还有一种支援协程的（Icon 或 Scheme），另外一种支持并发的（Sisal）。 ◇记住，在“计算机科学”里有“计算机”一词。 理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。 ◇参加语言标准化工作。 这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。 ◇知道自己应该在何时脱身于语言标准化 　　所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。 　　弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一文给出了寻找顶级设计师的三条建议： ◇尽早系统地识别出顶级设计师。 ◇分配一个人作为其职业规划的导师。 ◇给予机遇让成长中的设计师互相磨砺。</p>

<p>　　此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：“_假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。_”</p>

<p>　　所以，简单地买一本 Java 书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。</p>
</blockquote>

<p><strong>俺博客上，和本文相关的帖子（需翻墙）</strong>：</p>

<p>《<a href="https://program-think.blogspot.com/2009/01/0.html">如何成为优秀开发人员</a>》（系列）<br />
《<a href="https://program-think.blogspot.com/2009/08/why-choose-python-0-overview.html">为什么俺推荐 Python</a>》（系列）<br />
《<a href="https://program-think.blogspot.com/2009/01/defect-of-java-beginner-0-overview.html">Java 新手的通病</a>》（系列）<br />
《<a href="https://program-think.blogspot.com/2009/01/cxx-cross-platform-develop-0-overview.html">C++ 的移植性和跨平台开发</a>》（系列）</p>

            </div>
            
        </div>
    </div>
</div>


    </div>
</div>

<footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <br><br>
            <span>友链：<a href="https://program-think.blogspot.com/">编程随想的博客</a>
            <span>友链：<a href="http://www.xys.org/">新语丝</a>
                <span> </span><a href="https://twitter.com/fangshimin">方舟子 Twitter</a>
            </span>
            <br><br>
            Copyright &copy; 编程随想镜像站 2021
        </p>
    </div>
</footer>

<script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script>
</body>

</html>